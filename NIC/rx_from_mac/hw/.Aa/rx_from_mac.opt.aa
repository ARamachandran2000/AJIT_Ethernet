$constant  B : $uint<3>:= 5  
$constant  H : $uint<3>:= 4  
$constant  S0 : $uint<3>:= 0  
$constant  S1 : $uint<3>:= 1  
$constant  S2 : $uint<3>:= 2  
$constant  S3 : $uint<3>:= 3  
$storage  buffer_1 : $array[1024] $of $uint<37> // memory space index = 0  base address = 0  word size = 37
// can point into 
$storage  buffer_2 : $array[1024] $of $uint<37> // memory space index = 1  base address = 0  word size = 37
// can point into 
$pipe  mac_data : $uint<37>  $depth 1024 
// can point into 
$pipe  mac_to_nic_data : $uint<37>  $depth 1024 
// can point into 
$pipe  nic_rx_to_header : $uint<37>  $depth 1024 
// can point into 
$pipe  nic_rx_to_packet : $uint<37>  $depth 1024 
// can point into 
$storage  packet_buffer : $array[1024] $of $uint<37> // memory space index = 2  base address = 0  word size = 1
// can point into 
$pipe  tb_in_pipe : $uint<64>  $depth 1024 
// can point into 
$pipe  tb_out_packet_pipe : $uint<64>  $depth 1024 
// can point into 
$pipe  tb_out_pipe : $uint<64>  $depth 1024 
// can point into 
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$volatile $module [isWriteToHeader]
$in ( LSTATE : $uint<3>   HLEN : $uint<4>   PLEN : $uint<16>  )
$out ( write_to_header : $uint<1>  )
$is
{
  $volatile header_not_available := (LSTATE == B) $buffering 1
  write_to_header := ( $mux header_not_available ($bitcast ($uint<1>) _b0  )  ($bitcast ($uint<1>) _b1  ) )  $buffering 1
}
$module [load_buffer1]
$in ()
$out ( next_buf_ptr_out : $uint<10>   pckt_status : $uint<1>  )
$is
{
  $branchblock [pckt_good_check_fast]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi intm_data := 			  mac_data $on   $entry 			  mac_data $on   $loopback 
    // type of target is $uint<37>
    $phi buf_ptr := 			  ($bitcast ($uint<10>) _b0  ) $on   $entry 			  next_buf_ptr $on   $loopback 
    // type of target is $uint<10>
    $endmerge
    $volatile tlast := ( $slice intm_data 36 36 )  $buffering 1
    $volatile tdata := ( $slice intm_data 35 4 )  $buffering 1
    $volatile tkeep := ( $slice intm_data 3 0 )  $buffering 1
    $volatile bad_packet := (((tlast == 1 ) & (tdata == _hFFFFFFFF )) & (tkeep == 0 )) $buffering 1
    $volatile good_packet := ((tlast == 1 ) & (tkeep != 0 )) $buffering 1
    buffer_1[buf_ptr] := intm_data $buffering 1// bits of buffering = 37. 
    $volatile next_buf_ptr := (buf_ptr + 1 ) $buffering 1
    $while (tlast == 0 )
    $volatile next_buf_ptr_out := next_buf_ptr $buffering 1
    $volatile pckt_status := ( $mux good_packet ($bitcast ($uint<1>) _b1  )  ( $mux bad_packet ($bitcast ($uint<1>) _b0  )  ($bitcast ($uint<1>) _b0  ) )  )  $buffering 1
  }
}
$module [load_buffer2]
$in ()
$out ( next_buf_ptr_out : $uint<10>   pckt_status : $uint<1>  )
$is
{
  $branchblock [pckt_good_check_fast]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi intm_data := 			  mac_data $on   $entry 			  mac_data $on   $loopback 
    // type of target is $uint<37>
    $phi buf_ptr := 			  ($bitcast ($uint<10>) _b0  ) $on   $entry 			  next_buf_ptr $on   $loopback 
    // type of target is $uint<10>
    $endmerge
    $volatile tlast := ( $slice intm_data 36 36 )  $buffering 1
    $volatile tdata := ( $slice intm_data 35 4 )  $buffering 1
    $volatile tkeep := ( $slice intm_data 3 0 )  $buffering 1
    $volatile bad_packet := (((tlast == 1 ) & (tdata == _hFFFFFFFF )) & (tkeep == 0 )) $buffering 1
    $volatile good_packet := ((tlast == 1 ) & (tkeep != 0 )) $buffering 1
    buffer_2[buf_ptr] := intm_data $buffering 1// bits of buffering = 37. 
    $volatile next_buf_ptr := (buf_ptr + 1 ) $buffering 1
    $while (tlast == 0 )
    $volatile next_buf_ptr_out := next_buf_ptr $buffering 1
    $volatile pckt_status := ( $mux good_packet ($bitcast ($uint<1>) _b1  )  ( $mux bad_packet ($bitcast ($uint<1>) _b0  )  ($bitcast ($uint<1>) _b0  ) )  )  $buffering 1
  }
}
$volatile $module [nextDESTMAC]
$in ( LSTATE : $uint<3>   DESTMAC : $uint<48>   RX : $uint<37>  )
$out ( nDESTMAC : $uint<48>  )
$is
{
  $volatile S0_state := (LSTATE == S0) $buffering 1
  $volatile S1_state := (LSTATE == S1) $buffering 1
  $volatile not_both := (( ~ S0_state ) & ( ~ S1_state )) $buffering 1
  nDESTMAC := ((( $mux S0_state ($bitcast ($uint<48>) ( $slice RX 35 4 )  )  _b0  )  | ( $mux S1_state (( $slice RX 19 4 )  && ( $slice DESTMAC 31 0 ) )  _b0  ) ) | ( $mux not_both DESTMAC  _b0  ) ) $buffering 1
}
$volatile $module [nextLSTATE]
$in ( RX : $uint<37>   LSTATE : $uint<3>   HLEN : $uint<4>   PLEN : $uint<16>  )
$out ( nLSTATE : $uint<3>   nHLEN : $uint<4>   nPLEN : $uint<16>  )
$is
{
  $volatile n_state_is_B := (((LSTATE == H) | (PLEN > 2 )) & (HLEN <= 1 )) $buffering 1
  $volatile n_state_is_S0 := ((LSTATE == B) & (PLEN <= 2 )) $buffering 1
  nLSTATE := (((( $mux (LSTATE == S0) S1  _b0  )  | ( $mux (LSTATE == S1) S2  _b0  ) ) | ( $mux (LSTATE == S2) S3  _b0  ) ) | ((( $mux ((LSTATE == S3) | (HLEN > 1 )) H  _b0  )  | ( $mux n_state_is_B B  _b0  ) ) | ( $mux n_state_is_S0 S0  _b0  ) )) $buffering 1
  $volatile H_state := (nLSTATE == H) $buffering 1
  nHLEN := ( $mux H_state ( $mux (LSTATE == S3) ( $slice RX 27 24 )   (HLEN - 1 ) )   HLEN )  $buffering 1
  $volatile B_state := (nLSTATE == B) $buffering 1
  nPLEN := ( $mux (B_state | H_state) ( $mux (LSTATE == S3) ( $slice RX 19 4 )   (PLEN - 4 ) )   PLEN )  $buffering 1
}
$volatile $module [nextSRCMAC]
$in ( LSTATE : $uint<3>   SRCMAC : $uint<48>   RX : $uint<37>  )
$out ( nSRCMAC : $uint<48>  )
$is
{
  $volatile S1_state := (LSTATE == S1) $buffering 1
  $volatile S2_state := (LSTATE == S2) $buffering 1
  $volatile not_both := (( ~ S2_state ) & ( ~ S2_state )) $buffering 1
  nSRCMAC := ((( $mux S1_state ($bitcast ($uint<48>) ( $slice RX 35 20 )  )  _b0  )  | ( $mux S2_state (( $slice RX 35 4 )  && ( $slice SRCMAC 15 0 ) )  _b0  ) ) | ( $mux not_both SRCMAC  _b0  ) ) $buffering 1
}
$module [nicRxFromMacDaemon]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi TOTAL_STATE := 			  ($bitcast ($uint<119>) _b0  ) $on   $entry 			  nTOTAL_STATE $on   $loopback 
    // type of target is $uint<119>
    $phi RX := 			  mac_to_nic_data $on   $entry ,   $loopback 
    // type of target is $uint<37>
    $endmerge
    $volatile LSTATE := ( $slice TOTAL_STATE 118 116 )  $buffering 1
    $volatile SRCMAC := ( $slice TOTAL_STATE 115 68 )  $buffering 1
    $volatile DESTMAC := ( $slice TOTAL_STATE 67 20 )  $buffering 1
    $volatile HLEN := ( $slice TOTAL_STATE 19 16 )  $buffering 1
    $volatile PLEN := ( $slice TOTAL_STATE 15 0 )  $buffering 1
    $report (nicRxFromMacDaemon data_is 			 RX RX 			 TOTAL_STATE TOTAL_STATE 			 LSTATE LSTATE 			 SRCMAC SRCMAC 			 DESTMAC DESTMAC 			 HLEN HLEN 			 PLEN PLEN )
    $volatile 			$call nextLSTATE (RX LSTATE HLEN PLEN ) (nLSTATE nHLEN nPLEN ) 
    $volatile 			$call nextSRCMAC (LSTATE SRCMAC RX ) (nSRCMAC ) 
    $volatile 			$call nextDESTMAC (LSTATE DESTMAC RX ) (nDESTMAC ) 
    $volatile 			$call isWriteToHeader (LSTATE HLEN PLEN ) (write_to_header ) 
    $guard (write_to_header) nic_rx_to_header := RX $buffering 1// bits of buffering = 37. 
    nic_rx_to_packet := RX $buffering 1// bits of buffering = 37. 
    $report (nicRxFromMaDaemon data2 			 write_to_header write_to_header )
    $volatile nTOTAL_STATE := (((nLSTATE && nSRCMAC) && nDESTMAC) && (nHLEN && nPLEN)) $buffering 1
    $report (nicRxFromMacDaemon modified_data 			 nTOTAL_STATE nTOTAL_STATE 			 nLSTATE nLSTATE 			 nSRCMAC nSRCMAC 			 nDESTMAC nDESTMAC 			 nHLEN nHLEN 			 nPLEN nPLEN )
    $while 1 
  }
}
$module [read_from_tb]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi idata := 			  tb_in_pipe $on   $entry ,   $loopback 
    // type of target is $uint<64>
    $endmerge
    send_data := ( $slice idata 36 0 )  $buffering 1// bits of buffering = 37. 
    mac_data := send_data $buffering 1// bits of buffering = 37. 
    $while 1 
  }
}
$module [send_to_nic1]
$in ( buf_ptr : $uint<10>  )
$out ()
$is
{
  $branchblock [main]
  {
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<10>) _b0  ) $on   $entry 			  num $on   $loopback 
    // type of target is $uint<10>
    $endmerge
    mac_to_nic_data := buffer_1[I] $buffering 1// bits of buffering = 37. 
    $volatile num := (I + 1 ) $buffering 1
    $while (num < buf_ptr)
  }
}
$module [send_to_nic2]
$in ( buf_ptr : $uint<10>  )
$out ()
$is
{
  $branchblock [main]
  {
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<10>) _b0  ) $on   $entry 			  num $on   $loopback 
    // type of target is $uint<10>
    $endmerge
    mac_to_nic_data := buffer_2[I] $buffering 1// bits of buffering = 37. 
    $volatile num := (I + 1 ) $buffering 1
    $while (num < buf_ptr)
  }
}
$module [rx_fifo_reader]
$in ()
$out ()
$is
{
  $branchblock [pckt_good_check_fast]
  {
    $merge $entry loopback 
    $endmerge
    $call load_buffer1 () (last_written_pointer_1 packet_status_1 ) 
    $guard (packet_status_1) $call send_to_nic1 (last_written_pointer_1 ) () 
    $call load_buffer2 () (last_written_pointer_2 packet_status_2 ) 
    $guard (packet_status_2) $call send_to_nic2 (last_written_pointer_2 ) () 
    $place[loopback]
  }
}
$module [send_header_to_tb]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi rhdata := 			  nic_rx_to_header $on   $entry ,   $loopback 
    // type of target is $uint<37>
    $endmerge
    tb_out_pipe := ($bitcast ($uint<64>) rhdata ) $buffering 1// bits of buffering = 64. 
    $while 1 
  }
}
$module [send_packet_to_tb]
$in ()
$out ()
$is
{
  $branchblock [loop1]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi rpdata := 			  nic_rx_to_packet $on   $entry ,   $loopback 
    // type of target is $uint<37>
    $endmerge
    tb_out_packet_pipe := ($bitcast ($uint<64>) rpdata ) $buffering 1// bits of buffering = 64. 
    $while 1 
  }
}
// Memory space 0: buffer_1 
// Memory space 1: buffer_2 
// Memory space 2: packet_buffer 
