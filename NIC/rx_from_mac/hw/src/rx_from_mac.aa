// 
//
//	Total states:
//		Where are we in the packet.
//		S0	S1	S2	S3	H	B
//		start	src_dest_mac_addr	Header	packet	
//						length	length
//


//	start im S0,
//		Read 1st word -> dest_mac_addr[31:0]
//		write to header_pipe, packet_pipe
//		->go to S1

//	In S1,
//		read 2nd word -> dest_mac_addr[47:32], src_mac_addr[15:0]
//		write hader_pipe, packet_pipe
//		->go to S2

//	In S2,
//		read 3rd word -> src_mac_addr[47:16]
//		write hader_pipe, packet_pipe
//		->go to S3

//	In S3,
//		read 4th word -> packet_length, version,header_length
//		write to heder_pipe, packet_pipe.
//		-> go to H

//	In H,
//		read header_length words
//		write to header_pipe, packet_pipe
//			decrement header_length
//		-> go to B after header_length reaches 1/0?

//	In B,
//		read packet_length words
//		write to packet_pipe
//			decrement packet_length
//		-> goto to S1(reset all lengths etc) after
//			packet_length reaches 1/0?

$constant S0: $uint<3> := 0
$constant S1: $uint<3> := 1
$constant S2: $uint<3> := 2
$constant S3: $uint<3> := 3
$constant H:  $uint<3> := 4
$constant B:  $uint<3> := 5

$module [nicRxFromMacDaemon] $in () $out () $is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
			//Where are we in the packet.
			//S0	S1	S2	S3	H	B
			//start	src_&_dest_mac_addr	Header	packet	
			//				length	length
			// localState	src_mac_addr	dest_mac_addr	header_length	packet_lenght
			//	3	    48		     48		     4		     16
			//						 (in 32 bit)	 (in 8 bit)
			
				$phi TOTAL_STATE := $zero<119> $on $entry nTOTAL_STATE $on $loopback
				$phi RX := mac_to_nic_data $on $entry, $loopback
			$endmerge
			$volatile $split (TOTAL_STATE 3 48 48 4 16)
						(LSTATE SRCMAC DESTMAC HLEN PLEN)
			$rreport(nicRxFromMacDaemon data_is RX TOTAL_STATE LSTATE SRCMAC DESTMAC HLEN PLEN)
			$volatile $call nextLSTATE (RX LSTATE HLEN PLEN) (nLSTATE nHLEN nPLEN)
			$volatile $call nextSRCMAC (LSTATE SRCMAC RX) (nSRCMAC)
			$volatile $call nextDESTMAC (LSTATE DESTMAC RX) (nDESTMAC)
		
			$volatile $call isWriteToHeader (LSTATE HLEN PLEN) (write_to_header)
			//$volatile $call isWriteToPacket (LSTATE HLEN PLEN) (write_to_packet)
			
			$guard (write_to_header) nic_rx_to_header := RX 
			//$guard (write_to_packet) 
			nic_rx_to_packet := RX
			$rreport(nicRxFromMaDaemon data2 write_to_header)
			$volatile nTOTAL_STATE := ($concat nLSTATE nSRCMAC nDESTMAC nHLEN nPLEN)
			$rreport(nicRxFromMacDaemon modified_data nTOTAL_STATE nLSTATE nSRCMAC nDESTMAC nHLEN nPLEN)
		$while 1	
	}

}

$volatile $module [isWriteToHeader]
	$in (LSTATE: $uint<3> HLEN: $uint<4> PLEN: $uint<16> )
	$out(write_to_header: $uint<1>)
$is
{
	$volatile header_not_available := (LSTATE == B) 
	write_to_header := ($mux header_not_available $zero<1>	$one<1>)
}

//$volatile $module [isWriteToPacket]
//	$in (LSTATE: $uint<3> HLEN: $uint<4> PLEN: $uint<16>)
//	$out(write_to_packet: $uint<1>)
//$is
//{
//	$volatile packet_remaining := (PLEN > 0)
//	write_to_packet := ($mux packet_remaining $one<1> $zero<1>)
//}

$volatile $module [nextSRCMAC]
	$in (LSTATE: $uint<3> SRCMAC: $uint<48> RX: $uint<37>)
	$out(nSRCMAC: $uint<48>)
$is
{
	$volatile S1_state := (LSTATE == S1)
	$volatile S2_state := (LSTATE == S2)
	$volatile not_both := ((~S2_state) & (~S2_state))
	nSRCMAC := ($excmux 
			S1_state ($bitcast ($uint<48>) ($slice RX 35 20))
			S2_state ($concat ($slice RX 35 4) ($slice SRCMAC 15 0))
			not_both SRCMAC)
}

$volatile $module [nextDESTMAC]
        $in (LSTATE: $uint<3> DESTMAC: $uint<48> RX: $uint<37>)
        $out(nDESTMAC: $uint<48>)
$is
{
        $volatile S0_state := (LSTATE == S0)
        $volatile S1_state := (LSTATE == S1)
	$volatile not_both := ((~S0_state)&(~S1_state))
        nDESTMAC := ($excmux
                        S0_state ($bitcast ($uint<48>) ($slice RX 35 4))
                        S1_state ($concat ($slice RX 19 4) ($slice DESTMAC 31 0))
			not_both DESTMAC)
}

$volatile $module [nextLSTATE] 
	$in (RX: $uint<37> LSTATE: $uint<3> HLEN: $uint<4> PLEN: $uint<16>)
	$out(nLSTATE: $uint<3> nHLEN: $uint<4> nPLEN: $uint<16>)
$is
{
	$volatile n_state_is_B := (((LSTATE == H) | (PLEN > 2)) & (HLEN <= 1)) // can be zero lets decide later
	$volatile n_state_is_S0 := ((LSTATE == B) & (PLEN <= 2))
	nLSTATE := ($excmux 
			(LSTATE == S0)			S1
			(LSTATE == S1)			S2
			(LSTATE == S2)			S3
			((LSTATE == S3)|(HLEN > 1))	H
			n_state_is_B			B
			n_state_is_S0			S0)
	$volatile H_state := (nLSTATE == H)
	nHLEN := ($mux  H_state 
			($mux	(LSTATE == S3)
				($slice RX 27 24)
				(HLEN - 1)) 
			HLEN)
	$volatile B_state := (nLSTATE == B)
	nPLEN := ($mux (B_state | H_state)
			($mux	(LSTATE == S3)
				($slice RX 19 4)
				(PLEN - 4)) 
			PLEN)
	
}

$module [rx_fifo_reader] $in() $out()
$is
{

$branchblock[pckt_good_check_fast]
{

	
	$merge $entry loopback $endmerge

		$call load_buffer1 () (last_written_pointer_1 packet_status_1)
		//$rreport (rx_fifo_reader packet_status_1 packet_status_1)
		$guard (packet_status_1)
			$call send_to_nic1 (last_written_pointer_1) ()


		$call load_buffer2 () (last_written_pointer_2 packet_status_2)
		//$rreport (rx_fifo_reader packet_status_2 packet_status_2)
		$guard (packet_status_2)
			$call send_to_nic2 (last_written_pointer_2) ()
				 

	$place [loopback]

}

}



$module [send_to_nic1] $in(buf_ptr : $uint<10>) $out()
$is
{

//$rreport (send_to_nic1 sending_nic1 buf_ptr)
	
$branchblock [main] 
{
	
	$dopipeline $depth 5 $fullrate
		$merge $entry $loopback
			$phi I := $zero<10> $on $entry num $on $loopback
		$endmerge
		mac_to_nic_data := buffer_1[I]
		$volatile num := (I+1)
		//$rreport (send_to_nic1 num_val num)
	$while(num<buf_ptr)

}
}

$module [send_to_nic2] $in(buf_ptr : $uint<10>) $out()
$is
{

//$rreport (send_to_nic2 sending_nic2 buf_ptr)
	
$branchblock [main] 
{
	$dopipeline $depth 5 $fullrate
		$merge $entry $loopback
			$phi I := $zero<10> $on $entry num $on $loopback
		$endmerge
		mac_to_nic_data := buffer_2[I]
		$volatile num := (I+1)
		//$rreport (send_to_nic2 num_val out_data)
	$while(num<buf_ptr)

}
}



$module [load_buffer1] $in () $out(next_buf_ptr_out:$uint<10> pckt_status : $uint<1>) 
$is
{
$branchblock[pckt_good_check_fast]
{
	$dopipeline $depth 7 $fullrate 
		$merge $entry $loopback
			$phi intm_data := mac_data $on $entry mac_data $on $loopback 
			   
			$phi buf_ptr := $zero<10> $on $entry next_buf_ptr $on $loopback
							
		$endmerge
	
	
	$volatile $split (intm_data 1 32 4) (tlast tdata tkeep)

	$volatile bad_packet := (((tlast == 1) & (tdata == _hFFFFFFFF)) & (tkeep == 0))
	
	$volatile good_packet := ((tlast == 1) & (tkeep != 0))
	
	
	buffer_1[buf_ptr] := intm_data
	
	 
	$volatile next_buf_ptr := (buf_ptr + 1)
	//$rreport (load_buffer1 fill_buffer_val fill_buffer)
	//$rreport (load_buffer1 got_data tlast)
	$while (tlast == 0)


$volatile next_buf_ptr_out := next_buf_ptr

$volatile pckt_status := ($prioritymux good_packet $one<1>
			  	       bad_packet $zero<1> 
				       $default $zero<1>)
 
}

} 



$module [load_buffer2] $in () $out(next_buf_ptr_out:$uint<10> pckt_status : $uint<1>) 
$is
{
$branchblock[pckt_good_check_fast]
{
	$dopipeline $depth 7 $fullrate 
		$merge $entry $loopback
			$phi intm_data := mac_data $on $entry mac_data $on $loopback 
						   
			$phi buf_ptr := $zero<10> $on $entry next_buf_ptr $on $loopback
							
		$endmerge
	
	
	$volatile $split (intm_data 1 32 4) (tlast tdata tkeep)

	$volatile bad_packet := (((tlast == 1) & (tdata == _hFFFFFFFF)) & (tkeep == 0))
	
	$volatile good_packet := ((tlast == 1) & (tkeep != 0))
	
	
	buffer_2[buf_ptr] := intm_data
	
	$volatile next_buf_ptr := (buf_ptr + 1)
		
	
	$while (tlast == 0)


$volatile next_buf_ptr_out := next_buf_ptr

$volatile pckt_status := ($prioritymux good_packet $one<1>
			  	       bad_packet $zero<1> 
				       $default $zero<1>)
 
}
}  



////////////////////////////////////////////////////////

// This module is a simple connection link between tb
//	and actual hardware.
// Reads 64 bit wide pipe(which is written by tb),
//	removes unwanted bits and writes to input pipe
//	of actual hardware.

////////////////////////////////////////////////////////
$module [read_from_tb] $in() $out()
$is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi idata := tb_in_pipe $on $entry,$loopback
			$endmerge
			send_data  := ($slice idata 36 0)
			mac_data := send_data
		$while 1
	}
}
////////////////////////////////////////////////////////

// This module is a simple connection link between tb
//	and actual hardware.
// Reads 37 bit wide pipe(which is written by HW),
//	convertes it to 64 bit data and writes to pipe 
//	which tb reads to check integrity of data.

////////////////////////////////////////////////////////
$module [send_header_to_tb] $in() $out()
$is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi rhdata := nic_rx_to_header $on $entry, $loopback
			$endmerge
			tb_out_pipe := ($bitcast ($uint<64>) rhdata)	
		$while 1
	}
}
$module [send_packet_to_tb] $in() $out()
$is
{
	$branchblock[loop1]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi rpdata := nic_rx_to_packet $on $entry, $loopback
			$endmerge
			tb_out_packet_pipe := ($bitcast ($uint<64>) rpdata)
		$while 1
	}
}
