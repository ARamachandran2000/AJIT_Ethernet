$pipe  AFB_NIC_REQUEST : $uint<74>  $depth 2 
// can point into 
$pipe  AFB_NIC_RESPONSE : $uint<33>  $depth 2 
// can point into 
$constant  BAD_PACKET_DATA : $uint<64>:= _hffffffffffffffff  
$pipe  CONTROL_REGISTER : $uint<32>  $depth 1  $signal 
// can point into 
$pipe  FREE_Q : $uint<36>  $depth 1  $signal 
// can point into 
$constant  FULL_BYTE_MASK : $uint<8>:= _b11111111  
$pipe  LAST_READ_TX_QUEUE_INDEX : $uint<6>  $depth 1  $signal 
// can point into 
$pipe  LAST_WRITTEN_RX_QUEUE_INDEX : $uint<6>  $depth 1  $signal 
// can point into 
$pipe  MEMORY_TO_NIC_RESPONSE : $uint<65>  $depth 2 
// can point into 
$pipe  NIC_REQUEST_REGISTER_ACCESS_PIPE : $uint<43>  $depth 2 
// can point into 
$pipe  NIC_RESPONSE_REGISTER_ACCESS_PIPE : $uint<33>  $depth 2 
// can point into 
$pipe  NIC_TO_MEMORY_REQUEST : $uint<110>  $depth 2 
// can point into 
$pipe  NUMBER_OF_SERVERS : $uint<32>  $depth 1  $signal 
// can point into 
$constant  QUEUE_SIZE_MASK : $uint<32>:= 256  
$constant  RX_QUEUES_REG_START_OFFSET : $uint<6>:= 2  
$constant  TX_QUEUES_REG_START_OFFSET : $uint<6>:= 10  
$constant  WAIT_TIME : $uint<10>:= 10  
$pipe  mac_to_nic_data : $uint<73>  $depth 2 
// can point into 
$pipe  nic_rx_to_header : $uint<73>  $depth 2 
// can point into 
$pipe  nic_rx_to_packet : $uint<73>  $depth 2 
// can point into 
$pipe  nic_to_mac_transmit_pipe : $uint<73>  $depth 2 
// can point into 
$module [AccessRegister]
$in ( rwbar : $uint<1>   bmask : $uint<4>   register_index : $uint<6>   wdata : $uint<32>  )
$out ( rdata : $uint<32>  )
$is
{
  $volatile request := ((rwbar && bmask) && (register_index && wdata)) $buffering 1
  NIC_REQUEST_REGISTER_ACCESS_PIPE := request $buffering 1// bits of buffering = 43. 
  response := NIC_RESPONSE_REGISTER_ACCESS_PIPE $buffering 1// bits of buffering = 33. 
  $volatile status := ( $slice response 32 32 )  $buffering 1
  $volatile rdata := ( $slice response 31 0 )  $buffering 1
}
$pipeline $depth 15 $buffering 1 $fullrate $module [accessMemory]
$in ( lock : $uint<1>   rwbar : $uint<1>   bmask : $uint<8>   addr : $uint<36>   wdata : $uint<64>  )
$out ( rdata : $uint<64>  )
$is
{
  $volatile request := (((lock && rwbar) && bmask) && (addr && wdata)) $buffering 1
  NIC_TO_MEMORY_REQUEST := request $buffering 1// bits of buffering = 110. 
  response := MEMORY_TO_NIC_RESPONSE $buffering 1// bits of buffering = 65. 
  $volatile err := ( $slice response 64 64 )  $buffering 1
  $volatile rdata := ( $slice response 63 0 )  $buffering 1
}
$module [acquireMutex]
$in ( q_base_address : $uint<36>  )
$out ( m_ok : $uint<1>  )
$is
{
  $branchblock [loop]
  {
    $volatile mutex_address := q_base_address $buffering 1
    $merge $entry loopback 
    $endmerge
    $call accessMemory (($bitcast ($uint<1>) _b1 ) ($bitcast ($uint<1>) _b1 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) mutex_address ($bitcast ($uint<64>) _b0 ) ) (mutex_plus_nentries ) 
    $volatile mutex_val := ( $slice mutex_plus_nentries 63 32 )  $buffering 1
    $volatile wval := (($bitcast ($uint<32>) _b1 ) && ( $slice mutex_plus_nentries 31 0 ) ) $buffering 1
    $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) mutex_address wval ) (ignore ) 
    $if (mutex_val == 0 ) $then 
    $place[loopback]
    $endif
  }
  m_ok := ($bitcast ($uint<1>) _b1 ) $buffering 1// bits of buffering = 1. 
}
$module [getQueuePointers]
$in ( q_base_address : $uint<36>  )
$out ( wp : $uint<32>   rp : $uint<32>  )
$is
{
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b1 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) (q_base_address + 8 ) ($bitcast ($uint<64>) _b0 ) ) (wp_rp ) 
  $volatile wp := ( $slice wp_rp 63 32 )  $buffering 1
  $volatile rp := ( $slice wp_rp 31 0 )  $buffering 1
}
$module [getQueueElement]
$in ( q_base_address : $uint<36>   read_pointer : $uint<32>  )
$out ( q_r_data : $uint<32>  )
$is
{
  $volatile buffer_address := (q_base_address + ($bitcast ($uint<36>) 16  )) $buffering 1
  $volatile element_pair_address := (buffer_address + ($bitcast ($uint<36>) (( $slice read_pointer 31 1 )  && ($bitcast ($uint<3>) _b0 )) )) $buffering 1
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b1 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) element_pair_address ($bitcast ($uint<64>) _b0 ) ) (element_pair ) 
  $volatile e0 := ( $slice element_pair 63 32 )  $buffering 1
  $volatile e1 := ( $slice element_pair 31 0 )  $buffering 1
  q_r_data := ( $mux (read_pointer [] 0 ) e1  e0 )  $buffering 1// bits of buffering = 32. 
}
$module [setQueuePointers]
$in ( q_base_address : $uint<36>   wp : $uint<32>   rp : $uint<32>  )
$out ()
$is
{
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) (q_base_address + 8 ) (wp && rp) ) (ignore ) 
}
$module [releaseMutex]
$in ( q_base_address : $uint<36>  )
$out ()
$is
{
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) (( ~ ($bitcast ($uint<4>) _b0 ) ) && ($bitcast ($uint<4>) _b0 )) q_base_address ($bitcast ($uint<64>) _b0 ) ) (ignore ) 
}
$module [popFromQueue]
$in ( lock : $uint<1>   q_base_address : $uint<36>  )
$out ( q_r_data : $uint<32>   status : $uint<1>  )
$is
{
  $guard (lock) $call acquireMutex (q_base_address ) (m_ok ) 
  $barrier
  $call getQueuePointers (q_base_address ) (write_pointer read_pointer ) 
  $volatile q_empty := (write_pointer == read_pointer) $buffering 1
  $volatile next_rp := ((read_pointer + 1 ) & QUEUE_SIZE_MASK) $buffering 1
  $guard (~q_empty) $call getQueueElement (q_base_address read_pointer ) (q_r_data ) 
  $guard (~q_empty) $call setQueuePointers (q_base_address write_pointer next_rp ) () 
  $barrier
  $guard (lock) $call releaseMutex (q_base_address ) () 
  status := ( ~ q_empty ) $buffering 1// bits of buffering = 1. 
}
$module [writeEthernetHeaderToMem]
$in ( buf_pointer : $uint<36>  )
$out ( buf_position : $uint<36>  )
$is
{
  $branchblock [main]
  {
    $dopipeline $depth 15 $buffering 1
    $merge $entry $loopback 
    $phi buf_position := 			  (buf_position + 8 ) $on   $loopback 			  (buf_pointer + 8 ) $on   $entry 
    // type of target is $uint<36>
    $phi I := 			  ($bitcast ($uint<4>) _b0 ) $on   $entry 			  nI $on   $loopback 
    // type of target is $uint<4>
    $phi ethernet_header := 			  nic_rx_to_header $on   $entry ,   $loopback 
    // type of target is $uint<73>
    $endmerge
    $report (writeEthernetHeaderToMem received_eth_header_is 			 ethernet_header ethernet_header )
    $volatile last_bit := ( $slice ethernet_header 72 72 )  $buffering 1
    $volatile wdata := ( $slice ethernet_header 71 8 )  $buffering 1
    $volatile wkeep := ( $slice ethernet_header 7 0 )  $buffering 1
    $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) wkeep buf_position wdata ) (ignore_return ) 
    $volatile nI := (I + 1 ) $buffering 1
    $while (nI <= 1 )
  }
  $attribute delay 4
}
$module [writePayloadToMem]
$in ( base_buf_pointer : $uint<36>   buf_pointer : $uint<36>  )
$out ( packet_size_32 : $uint<8>   bad_packet_identifier : $uint<1>   last_keep : $uint<8>  )
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 15 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi buf_position := 			  (buf_pointer + 8 ) $on   $entry 			  (buf_position + 8 ) $on   $loopback 
    // type of target is $uint<36>
    $phi payload_data := 			  nic_rx_to_packet $on   $entry ,   $loopback 
    // type of target is $uint<73>
    $endmerge
    $volatile last_bit := ( $slice payload_data 72 72 )  $buffering 1
    $volatile wdata := ( $slice payload_data 71 8 )  $buffering 1
    $volatile wkeep := ( $slice payload_data 7 0 )  $buffering 1
    $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) wkeep buf_position wdata ) (ignore_return ) 
    $while ( ~ last_bit )
  }
  ( buf_position => buf_position  wdata => tdata  wkeep => tkeep )
  $volatile bad_packet_identifier := ((tdata == BAD_PACKET_DATA) & (tkeep == 0 )) $buffering 1
  $volatile packet_size_8 := ($bitcast ($uint<8>) ((buf_position - base_buf_pointer) + 1 ) ) $buffering 1
  $volatile packet_size_32 := (packet_size_8 << 2 ) $buffering 1
  $volatile last_keep := tkeep $buffering 1
}
$module [writeControlInformationToMem]
$in ( base_buffer_pointer : $uint<36>   packet_size : $uint<8>   last_keep : $uint<8>  )
$out ()
$is
{
  $volatile control_data := ($bitcast ($uint<64>) (packet_size && last_keep) ) $buffering 1
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) FULL_BYTE_MASK base_buffer_pointer control_data ) (ignore_return ) 
}
$pipeline $depth 31 $buffering 1 $module [loadBuffer]
$in ( rx_buffer_pointer : $uint<36>  )
$out ( bad_packet_identifier : $uint<1>  )
$is
{
  $call writeEthernetHeaderToMem (rx_buffer_pointer ) (new_buf_pointer ) 
  $call writePayloadToMem (rx_buffer_pointer new_buf_pointer ) (packet_size bad_packet_identifier last_keep ) 
  $guard (~bad_packet_identifier) $call writeControlInformationToMem (rx_buffer_pointer packet_size last_keep ) () 
}
$module [setQueueElement]
$in ( q_base_address : $uint<36>   write_pointer : $uint<32>   q_w_data : $uint<32>  )
$out ()
$is
{
  $volatile buffer_address := (q_base_address + ($bitcast ($uint<36>) 16  )) $buffering 1
  $volatile element_pair_address := (buffer_address + ($bitcast ($uint<36>) (( $slice write_pointer 31 1 )  && ($bitcast ($uint<3>) _b0 )) )) $buffering 1
  $volatile bmask := ( $mux (write_pointer [] 0 ) (($bitcast ($uint<4>) _b0 ) && ( ~ ($bitcast ($uint<4>) _b0 ) ))  (( ~ ($bitcast ($uint<4>) _b0 ) ) && ($bitcast ($uint<4>) _b0 )) )  $buffering 1
  $volatile wval := ( $mux (write_pointer [] 0 ) (($bitcast ($uint<32>) _b0 ) && q_w_data)  (q_w_data && ($bitcast ($uint<32>) _b0 )) )  $buffering 1
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) bmask element_pair_address wval ) (ignore ) 
}
$module [pushIntoQueue]
$in ( lock : $uint<1>   q_base_address : $uint<36>   q_w_data : $uint<32>  )
$out ( status : $uint<1>  )
$is
{
  $guard (lock) $call acquireMutex (q_base_address ) (m_ok ) 
  $barrier
  $call getQueuePointers (q_base_address ) (write_pointer read_pointer ) 
  $volatile next_wp := ((write_pointer + 1 ) & QUEUE_SIZE_MASK) $buffering 1
  $volatile q_full := (next_wp == read_pointer) $buffering 1
  $guard (~q_full) $call setQueueElement (q_base_address write_pointer q_w_data ) () 
  $guard (~q_full) $call setQueuePointers (q_base_address write_pointer next_wp ) () 
  $barrier
  $guard (lock) $call releaseMutex (q_base_address ) () 
  status := ( ~ q_full ) $buffering 1// bits of buffering = 1. 
}
$operator $module [delay_time]
$in ( T : $uint<32>  )
$out ( delay_done : $uint<1>  )
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi R := 			  nR $on   $loopback 			  T $on   $entry 
    // type of target is $uint<32>
    $endmerge
    $volatile nR := (R - 1 ) $buffering 1
    $while (R > 0 )
    $volatile delay_done := 1  $buffering 1
  }
}
$module [populateRxQueue]
$in ( rx_buffer_pointer : $uint<36>  )
$out ()
$is
{
  $branchblock [PushIntoQueue]
  {
    $merge $entry loopback 
    $phi q_index := 			  (LAST_WRITTEN_RX_QUEUE_INDEX + 1 ) $on   $entry 			  n_q_index $on   loopback 
    // type of target is $uint<6>
    $endmerge
    $volatile register_index := ($bitcast ($uint<6>) (q_index + RX_QUEUES_REG_START_OFFSET) ) $buffering 1
    $call AccessRegister (($bitcast ($uint<1>) _b1 ) ($bitcast ($uint<4>) _b1 ) register_index ($bitcast ($uint<32>) _b0 ) ) (rx_queue_pointer_32 ) 
    $volatile rx_queue_pointer_36 := (rx_queue_pointer_32 && ($bitcast ($uint<4>) _b0 )) $buffering 1
    $call pushIntoQueue (($bitcast ($uint<1>) _b0 ) rx_queue_pointer_36 ( $slice rx_buffer_pointer 35 4 )  ) (push_status ) 
    n_q_index := ((q_index + 1 ) & ($bitcast ($uint<6>) (NUMBER_OF_SERVERS - 1 ) )) $buffering 1// bits of buffering = 6. 
    $if ( ~ push_status ) $then 
    $call delay_time (32  ) (status ) 
    $if (status == 0 ) $then 
    $place[loopback]
    $endif
    $else 
    LAST_WRITTEN_RX_QUEUE_INDEX := q_index $buffering 1// bits of buffering = 6. 
    selected_q_index := q_index $buffering 1// bits of buffering = 6.  Orphaned statement with target selected_q_index ?? 
    $endif
  }
}
$module [ReceiveEngineDaemon]
$in ()
$out ()
$is
{
  LAST_WRITTEN_RX_QUEUE_INDEX := 0  $buffering 1// bits of buffering = 6. 
  $branchblock [main]
  {
    $merge $entry not_enabled_yet_loopback disable_loopback 
    $endmerge
    $if ( ~ (CONTROL_REGISTER [] 0 ) ) $then 
    $place[not_enabled_yet_loopback]
    $endif
    $report (ReceiveEngineDaemon got_the__control )
    $dopipeline $depth 31 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $endmerge
    $call popFromQueue (($bitcast ($uint<1>) _b1 ) FREE_Q ) (rx_buffer_pointer_32 status ) 
    $volatile rx_buffer_pointer_36 := (rx_buffer_pointer_32 && ($bitcast ($uint<4>) _b0 )) $buffering 1
    $guard (status) $call loadBuffer (rx_buffer_pointer_36 ) (bad_packet_identifier ) 
    $volatile ok_flag := (status & ( ~ bad_packet_identifier )) $buffering 1
    $volatile free_flag := (status & bad_packet_identifier) $buffering 1
    $guard (ok_flag) $call populateRxQueue (rx_buffer_pointer_36 ) () 
    $guard (free_flag) $call pushIntoQueue (($bitcast ($uint<1>) _b1 ) FREE_Q ( $slice rx_buffer_pointer_36 35 4 )  ) (push_status ) 
    $while (CONTROL_REGISTER [] 0 )
    $place[disable_loopback]
  }
}
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
