$pipe  AFB_NIC_REQUEST : $uint<74>  $depth 2 
// can point into 
$pipe  AFB_NIC_RESPONSE : $uint<33>  $depth 2 
// can point into 
$constant  BAD_PACKET_DATA : $uint<64>:= _hffffffffffffffff  
$pipe  CONTROL_REGISTER : $uint<32>  $depth 1  $signal 
// can point into 
$pipe  FREE_Q : $uint<36>  $depth 1  $signal 
// can point into 
$constant  FULL_BYTE_MASK : $uint<8>:= _b11111111  
$constant  HEADER_TKEEP : $uint<8>:= _b00111111  
$pipe  LAST_READ_TX_QUEUE_INDEX : $uint<6>  $depth 1  $signal 
// can point into 
$pipe  LAST_WRITTEN_RX_QUEUE_INDEX : $uint<6>  $depth 1  $signal 
// can point into 
$pipe  MEMORY_TO_NIC_RESPONSE : $uint<65>  $depth 2 
// can point into 
$pipe  NIC_REQUEST_REGISTER_ACCESS_PIPE : $uint<43>  $depth 2 
// can point into  foreign( $void )
$pipe  NIC_RESPONSE_REGISTER_ACCESS_PIPE : $uint<33>  $depth 2 
// can point into 
$pipe  NIC_TO_MEMORY_REQUEST : $uint<110>  $depth 2 
// can point into  foreign( $void )
$pipe  NUMBER_OF_SERVERS : $uint<32>  $depth 1  $signal 
// can point into 
$constant  QUEUE_SIZE_MASK : $uint<32>:= 256  
$constant  RX_QUEUES_REG_START_OFFSET : $uint<6>:= 2  
$constant  S0 : $uint<2>:= 0  
$constant  S1 : $uint<2>:= 1  
$constant  S2 : $uint<2>:= 2  
$constant  TX_QUEUES_REG_START_OFFSET : $uint<6>:= 10  
$constant  WAIT_TIME : $uint<10>:= 10  
$pipe  mac_to_nic_data : $uint<73>  $depth 2 
// can point into 
$pipe  nic_rx_to_header : $uint<73>  $depth 2 
// can point into 
$pipe  nic_rx_to_packet : $uint<73>  $depth 2 
// can point into 
$pipe  nic_to_mac_transmit_pipe : $uint<73>  $depth 2 
// can point into 
$module [AccessRegister]
$in ( rwbar : $uint<1>   bmask : $uint<4>   register_index : $uint<6>   wdata : $uint<32>  )
$out ( rdata : $uint<32>  )
$is
{
  $volatile request := ((rwbar && bmask) && (register_index && wdata)) $buffering 1
  NIC_REQUEST_REGISTER_ACCESS_PIPE := request $buffering 1// bits of buffering = 43. 
  response := NIC_RESPONSE_REGISTER_ACCESS_PIPE $buffering 1// bits of buffering = 33. 
  $volatile status := ( $slice response 32 32 )  $buffering 1
  $volatile rdata := ( $slice response 31 0 )  $buffering 1
}
$pipeline $depth 15 $buffering 1 $fullrate $module [accessMemory]
$in ( lock : $uint<1>   rwbar : $uint<1>   bmask : $uint<8>   addr : $uint<36>   wdata : $uint<64>  )
$out ( rdata : $uint<64>  )
$is
{
  $volatile request := (((lock && rwbar) && bmask) && (addr && wdata)) $buffering 1
  NIC_TO_MEMORY_REQUEST := request $buffering 1// bits of buffering = 110. 
  response := MEMORY_TO_NIC_RESPONSE $buffering 1// bits of buffering = 65. 
  $volatile err := ( $slice response 64 64 )  $buffering 1
  $volatile rdata := ( $slice response 63 0 )  $buffering 1
}
$module [acquireMutex]
$in ( q_base_address : $uint<36>  )
$out ( m_ok : $uint<1>  )
$is
{
  $branchblock [loop]
  {
    $volatile mutex_address := q_base_address $buffering 1
    $merge $entry loopback 
    $endmerge
    $call accessMemory (($bitcast ($uint<1>) _b1 ) ($bitcast ($uint<1>) _b1 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) mutex_address ($bitcast ($uint<64>) _b0 ) ) (mutex_plus_nentries ) 
    $volatile mutex_val := ( $slice mutex_plus_nentries 63 32 )  $buffering 1
    $volatile wval := (($bitcast ($uint<32>) _b1 ) && ( $slice mutex_plus_nentries 31 0 ) ) $buffering 1
    $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) mutex_address wval ) (ignore ) 
    $if (mutex_val == 0 ) $then 
    $place[loopback]
    $endif
  }
  m_ok := ($bitcast ($uint<1>) _b1 ) $buffering 1// bits of buffering = 1. 
}
$operator $module [delay_time]
$in ( T : $uint<32>  )
$out ( delay_done : $uint<1>  )
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi R := 			  nR $on   $loopback 			  T $on   $entry 
    // type of target is $uint<32>
    $endmerge
    $volatile nR := (R - 1 ) $buffering 1
    $while (R > 0 )
    $volatile delay_done := 1  $buffering 1
  }
}
$module [getQueueElement]
$in ( q_base_address : $uint<36>   read_pointer : $uint<32>  )
$out ( q_r_data : $uint<32>  )
$is
{
  $volatile buffer_address := (q_base_address + ($bitcast ($uint<36>) 16  )) $buffering 1
  $volatile element_pair_address := (buffer_address + ($bitcast ($uint<36>) (( $slice read_pointer 31 1 )  && ($bitcast ($uint<3>) _b0 )) )) $buffering 1
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b1 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) element_pair_address ($bitcast ($uint<64>) _b0 ) ) (element_pair ) 
  $volatile e0 := ( $slice element_pair 63 32 )  $buffering 1
  $volatile e1 := ( $slice element_pair 31 0 )  $buffering 1
  q_r_data := ( $mux (read_pointer [] 0 ) e1  e0 )  $buffering 1// bits of buffering = 32. 
}
$module [getQueuePointers]
$in ( q_base_address : $uint<36>  )
$out ( wp : $uint<32>   rp : $uint<32>  )
$is
{
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b1 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) (q_base_address + 8 ) ($bitcast ($uint<64>) _b0 ) ) (wp_rp ) 
  $volatile wp := ( $slice wp_rp 63 32 )  $buffering 1
  $volatile rp := ( $slice wp_rp 31 0 )  $buffering 1
}
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$volatile $module [nextLSTATE]
$in ( RX : $uint<73>   LSTATE : $uint<2>  )
$out ( nLSTATE : $uint<2>  )
$is
{
  $volatile tlast := ( $slice RX 72 72 )  $buffering 1
  $volatile tdata := ( $slice RX 71 8 )  $buffering 1
  $volatile tkeep := ( $slice RX 7 0 )  $buffering 1
  $volatile last_word := (tlast == 1 ) $buffering 1
  nLSTATE := ((( $mux (LSTATE == S0) S1  _b0  )  | ( $mux (LSTATE == S1) S2  _b0  ) ) | (( $mux ((LSTATE == S2) & ( ~ last_word )) S2  _b0  )  | ( $mux ((LSTATE == S2) & last_word) S0  _b0  ) )) $buffering 1
}
$module [nicRxFromMacDaemon]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi LSTATE := 			  S0 $on   $entry 			  nLSTATE $on   $loopback 
    // type of target is $uint<2>
    $phi RX := 			  mac_to_nic_data $on   $entry ,   $loopback 
    // type of target is $uint<73>
    $endmerge
    $report (nicRxFromMacDaemon data_is 			 RX RX 			 LSTATE LSTATE )
    $volatile 			$call nextLSTATE (RX LSTATE ) (nLSTATE ) 
    $volatile write_to_header := ((LSTATE == S0) | (LSTATE == S1)) $buffering 1
    $guard (write_to_header) nic_rx_to_header := ( $mux (LSTATE == S1) (( $slice RX 72 8 )  && HEADER_TKEEP)  RX )  $buffering 1// bits of buffering = 73. 
    nic_rx_to_packet := RX $buffering 1// bits of buffering = 73. 
    $report (nicRxFromMacDaemon data_written_is 			 RX RX )
    $while 1 
  }
}
$module [setQueuePointers]
$in ( q_base_address : $uint<36>   wp : $uint<32>   rp : $uint<32>  )
$out ()
$is
{
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) ( ~ ($bitcast ($uint<8>) _b0 ) ) (q_base_address + 8 ) (wp && rp) ) (ignore ) 
}
$module [releaseMutex]
$in ( q_base_address : $uint<36>  )
$out ()
$is
{
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) (( ~ ($bitcast ($uint<4>) _b0 ) ) && ($bitcast ($uint<4>) _b0 )) q_base_address ($bitcast ($uint<64>) _b0 ) ) (ignore ) 
}
$module [popFromQueue]
$in ( lock : $uint<1>   q_base_address : $uint<36>  )
$out ( q_r_data : $uint<32>   status : $uint<1>  )
$is
{
  $guard (lock) $call acquireMutex (q_base_address ) (m_ok ) 
  $barrier
  $call getQueuePointers (q_base_address ) (write_pointer read_pointer ) 
  $volatile q_empty := (write_pointer == read_pointer) $buffering 1
  $volatile next_rp := ((read_pointer + 1 ) & QUEUE_SIZE_MASK) $buffering 1
  $guard (~q_empty) $call getQueueElement (q_base_address read_pointer ) (q_r_data ) 
  $guard (~q_empty) $call setQueuePointers (q_base_address write_pointer next_rp ) () 
  $barrier
  $guard (lock) $call releaseMutex (q_base_address ) () 
  status := ( ~ q_empty ) $buffering 1// bits of buffering = 1. 
}
$module [setQueueElement]
$in ( q_base_address : $uint<36>   write_pointer : $uint<32>   q_w_data : $uint<32>  )
$out ()
$is
{
  $volatile buffer_address := (q_base_address + ($bitcast ($uint<36>) 16  )) $buffering 1
  $volatile element_pair_address := (buffer_address + ($bitcast ($uint<36>) (( $slice write_pointer 31 1 )  && ($bitcast ($uint<3>) _b0 )) )) $buffering 1
  $volatile bmask := ( $mux (write_pointer [] 0 ) (($bitcast ($uint<4>) _b0 ) && ( ~ ($bitcast ($uint<4>) _b0 ) ))  (( ~ ($bitcast ($uint<4>) _b0 ) ) && ($bitcast ($uint<4>) _b0 )) )  $buffering 1
  $volatile wval := ( $mux (write_pointer [] 0 ) (($bitcast ($uint<32>) _b0 ) && q_w_data)  (q_w_data && ($bitcast ($uint<32>) _b0 )) )  $buffering 1
  $call accessMemory (($bitcast ($uint<1>) _b0 ) ($bitcast ($uint<1>) _b0 ) bmask element_pair_address wval ) (ignore ) 
}
$module [pushIntoQueue]
$in ( lock : $uint<1>   q_base_address : $uint<36>   q_w_data : $uint<32>  )
$out ( status : $uint<1>  )
$is
{
  $guard (lock) $call acquireMutex (q_base_address ) (m_ok ) 
  $barrier
  $call getQueuePointers (q_base_address ) (write_pointer read_pointer ) 
  $volatile next_wp := ((write_pointer + 1 ) & QUEUE_SIZE_MASK) $buffering 1
  $volatile q_full := (next_wp == read_pointer) $buffering 1
  $guard (~q_full) $call setQueueElement (q_base_address write_pointer q_w_data ) () 
  $guard (~q_full) $call setQueuePointers (q_base_address write_pointer next_wp ) () 
  $barrier
  $guard (lock) $call releaseMutex (q_base_address ) () 
  status := ( ~ q_full ) $buffering 1// bits of buffering = 1. 
}
