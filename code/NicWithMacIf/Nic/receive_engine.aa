// This Module is responsible for reading the payload and the 
// ethernet header from the parser and sends it to memory


// States : 
// 1. Check Empty Buffer
// 2. Read from Parser and write to memory
// 3. Check if it is a bad packet based on last word



// Notes : If it is a bad packet then next packet can be loaded in the same location i.e no need to send
// request to memory.

//////////////////////////////////Global Variables//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$constant S0: $uint<2> := 0 // Empty Buffer Finding state
$constant S1: $uint<2> := 1 // Stores payload and header in memory
$constant S2: $uint<2> := 2 // Packet status checker and sets flag if good packet


$pipe request_pipe   : $uint<110> $depth 128  
$pipe response_pipe  : $uint<65>  $depth 128  
$pipe eth_header     : $uint<73>  $depth   5
$pipe eth_payload    : $uint<73>  $depth 128

$constant THREE: $uint<11> := 3
$constant Y_LIMIT : $uint<11> := 1544
$constant BUFFER_OFFSET : $uint<36> := 0

$volatile $module [checkEmptyBuf]
    $in (buf_index : $uint<9>)
    $out(done : $uint<1>)

    $is
    {
        $branchblock [main]
        {
            $merge $entry loopback

            $endmerge

//          $volatile $call addr_gen (buf_index 0) (mem_addr) // To be Implemented
            request_data := ($concat zero<1> one<1> _hff mem_addr _h0000000000000000) $mark DELAY
            
            // Need to ask sir How memory interface works.
            request_pipe := request_data $delay (DELAY 30)
            
            response_data := response_pipe
            processed_flag := response_data [] 7
            isBufEmpty := processed_flag

            $if (isBufEmpty) $then
                $place [loopback] // put token in place "loopback"
            $endif

            done := ( $mux (isBufEmpty)  (one<1>) (zero<1>))

        }

    }


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get bufLocation

// Inputs : 
//          Bad Packet status
//          previous buffer index

// Outputs : New Buffer Index (based on bad packet status)


$volatile $module [getBufLocation] 
    $in(bad_packet_status : $uint<1>
        prev_buffer_index : $uint<9> )
    
    $out(
        new_buffer_index : $uint<9>    
        )
    $is
    {
       // $guard(bad_packet_status)
         //   intm_buf_index_1 := prev_buffer_index
        
        //$guard(~bad_packet_status)$then
          //  intm_buf_index_2 := (prev_buffer_index + 1)
        
        //$volatile new_buffer_index := ( $mux (bad_packet_status)  (intm_buf_index_1) (intm_buf_index_2))
        $volatile new_buffer_index := ($mux bad_packet_status 
        					prev_buffer_index 
        					(prev_buffer_index + 1))

    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// write_eth_header_to_mem

// Inputs : buffer_index
	

// Outputs : header_write_done

$volatile $module [write_eth_header_to_mem]
	$in(buffer_index : $uint<9>)
	$out(header_write_done : $uint<1>)
$is
{
//	$volatile $call addr_gen (buffer_index 1) (mem_addr1) // To be Implemented
	data1 := eth_header
	$split (data1 1 64 8)(tlast1 tdata1 tkeep1)
	$volatile req_1 := ($concat zero<1> one<1> tkeep1 mem_addr1 tdata1 )
	request_pipe := req_1
	responce1 := response_pipe
	
	$volatile $call addr_gen (buffer_index 2) (mem_addr2) // To be Implemented
	data2 := eth_header
	$split (data2 1 64 8)(tlast2 tdata2 tkeep2)
	$volatile req_2 := ($concat zero<1> one<1> tkeep2 mem_addr2 tdata2 )
	request_pipe := req_2
	responce2 := response_pipe
	
	$volatile header_write_done := $one<1>
} 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// write_eth_payload_to_mem

// Inputs : buffer_index
	

// Outputs : done

$volatile $module [write_eth_payload_to_mem]
	$in(buffer_index : $uint<9>)
	$out(end_y_index:$uint<11> done, bad_packet : $uint<1>)
$is
{
	$barnchblock[main]
	{
		$merge $entry loopback
			$phi y_index := THREE $on $entry y_next $on loopback
		$endmerge
		
//		$volatile $call addr_gen (buffer_index y_index) (mem_addr) // To be Implemented
		data := eth_payload
		$split (data 1 64 8) (tlast tdata tkeep)
		$volatile req := ($concat $zero<1> $one<1> tkeep mem_adder tdata)
		request_pipe := req
		
		resp := response_pipe
		round_off := (y_index == Y_LIMIT)
		y_next := ($mux Y_LIMIT THREE (y_index + 1))
		
		$if(~t_last) $then
			$place[loopback]
		$endif
		
		bad_packet := ((tdata == _hffffffffffffffff) & (tkeep == 0))
		
		end_y_index := y_index
		
		done := $one<1>
		 
	}	
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// addr_gen

// Inputs : buffer_index
//	    y_index
	

// Outputs : mem_addr

$volatile $module [addr_gen]
	$in(buffer_index : $uint<9> y_index : $uint<11>)
	$out(mem_addr : $uint<36>)
$is
{
	// we need to review this as there may some issues
	// of size missmatch.
	mem_addr := ((BUFFER_OFFSET + (buffer_index * Y_LIMIT)) + (y_index * 8))
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Calculate next state 
// Inputs : Current State
//          done_0 done_1 done_2
// Outputs : New state

$volatile $module [calc_next_state]
    $in (done_0 : $uint<1>
         done_1 : $uint<1>
         done_2 : $uint<1>
         curr_state : $uint<2>)
    
    $out (next_state : $uint<2>)

    $is
    {
        next_state := ($excmux
                ((curr_state == S0) & done_0)   S1
                ((curr_state == S1) & done_1)   S2
                ((curr_state == S2) & done_2)   S0)

    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$module [receiverDaemon] $in () $out () $is
{
	$branchblock[main]
	{
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi curr_state_main := S0 $on $entry next_state $on $loopback
			$phi BAD_PACKET := $one<1> $on $entry bad_packet_prev $on $loopback
			$phi prev_buffer_index := $zero<9> $on $entry new_buffer_index $on $loopback
		$endmerge

            
		$guard(curr_state_main == S0)
			$volatile $call getBufLocation (BAD_PACKET prev_buf_index) (new_buffer_index)
            
		$guard ((curr_state_main == S0) & (~BAD_PACKET))
			$volatile $call checkEmptyBuf (new_buffer_index) (done_0)
            

		// State 1 here
		$guard(curr_state_main == S1)
			$volatile $call write_eth_header_to_mem (new_buffer_index) (header_write_done_1)
		
		$guard((curr_state_main == S1) & (header_write_done_1))
			$volatile $call write_eth_payload_to_mem (new_buffer_index) (end_y_index done_1 bad_packet_prev)	


		// State 2 here
		

		//Calculate Next State

		$call calc_next_state (done_0 done_1 done_2 curr_state_main) (next_state)

		$while 1
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

