// This Module is responsible for reading the payload and the 
// ethernet header from the parser and sends it to memory


// States : 
// 1. Check Empty Buffer
// 2. Read from Parser and write to memory
// 3. Check if it is a bad packet based on last word

// TODO : Need to ask sir How memory interface works.

// Notes : If it is a bad packet then next packet can be loaded in the same location i.e no need to send
// request to memory.


/*

State 0 :

	repeat
		1. Find empty buffer by reading flag buffer
		if flag == 8'd0
			buf <- i
			goto State 1

		else
			continue

	endrepeat


State 1 :
	Set x <- buf and y <- 0
	repeat
	1. Read from header pipe and payload pipe (one after other)
	2. Extract data ,tlast ,tkeep information from the 73-bit quantity
	3. Calculate address to write to based on the x,y index
	4. if not tlast
	Package the data into the 110-bit data format with byte mask as 0xFF
	Increment y and continue
	5. else
	Package the data into the 110-bit data format with byte mask set to tkeep
	break and goto State 2
	endrepeat


State 2 :
procedure
control_word = {36’b0 + y + tkeep + 8-bit flag}
1. Check if the last written word has the bad packet format
2. if yes
	Don’t set MSB flag bit in the control word
3. else
	Set MSB of flag bit

4. Send 64-bit Control word to flag buffer index x
	Go back to State 1

endprocedure









*/
















//////////////////////////////////Global Variables//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$constant S0: $uint<2> := 0 // Empty Buffer Finding state
$constant S1: $uint<2> := 1 // Stores payload and header in memory
$constant S2: $uint<2> := 2 // Packet status checker and sets flag if good packet



$pipe request_pipe   : $uint<110> $depth 128  
$pipe response_pipe  : $uint<65>  $depth 128  
$pipe eth_header     : $uint<73>  $depth   5
$pipe eth_payload    : $uint<73>  $depth 128

$constant THREE: $uint<12> := 3
$constant Y_LIMIT : $uint<12> := 1544
$constant BUFFER_OFFSET : $uint<36> := 0

$module [checkEmptyBuf]
    $in (buf_index : $uint<9>)
    $out(done : $uint<1>)

    $is
    {
        $branchblock [main]
        {
            $merge $entry loopback

            $endmerge

         	$volatile $call addr_gen (buf_index 0) (mem_addr) 
            request_data := ($concat $zero<1> $one<1> ($bitcast ($uint<8>) _hff) mem_addr ($bitcast ($uint<64>) _h0000000000000000)) $mark WAIT

			// Wait 30 clock cycles between requests            

            request_pipe := request_data $delay (WAIT 30)
            
            response_data := response_pipe
			flag := ($slice response_data 7 0)
            isBufEmpty := (flag == 0)

            $if (~isBufEmpty) $then
                $place [loopback] // put token in place "loopback"
            $endif

            done := $zero<1>

        }

    }


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get bufLocation

// Inputs : 
//          Bad Packet status
//          previous buffer index

// Outputs : New Buffer Index (based on bad packet status)


$module [getBufLocation] 
    $in(bad_packet_status : $uint<1>
        prev_buffer_index : $uint<9> )
    
    $out(
        new_buffer_index : $uint<9>    
        )
    $is
    {
        
        $volatile new_buffer_index := ($mux bad_packet_status 
        					prev_buffer_index 
        					(prev_buffer_index + 1))

    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// write_eth_header_to_mem

// Inputs : buffer_index
	

// Outputs : header_write_done

$module [write_eth_header_to_mem]
	$in(buffer_index : $uint<9>)
	$out(header_write_done : $uint<1>)
$is
{
	$volatile $call addr_gen (buffer_index 1) (mem_addr1) 
	data1 := eth_header
	$split (data1 1 64 8)(tlast1 tdata1 tkeep1)
	$volatile req_1 := ($concat $zero<1> $one<1> tkeep1 mem_addr1 tdata1 )
	request_pipe := req_1
	//response1 := response_pipe
	
	$volatile $call addr_gen (buffer_index 2) (mem_addr2) 
	data2 := eth_header
	$split (data2 1 64 8)(tlast2 tdata2 tkeep2)
	$volatile req_2 := ($concat $zero<1> $one<1> tkeep2 mem_addr2 tdata2 )
	request_pipe := req_2
	//response2 := response_pipe
	
	$volatile header_write_done := $one<1>
} 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// write_eth_payload_to_mem

// Inputs : buffer_index
	

// Outputs : done

$module [write_eth_payload_to_mem]
	$in(buffer_index : $uint<9>)
	$out(end_y_index:$uint<12> done : $uint<1> bad_packet : $uint<1> last_keep : $uint<8>)
$is
{
	$branchblock[main]
	{
		$merge $entry loopback
			$phi y_index := THREE $on $entry y_next $on loopback
		$endmerge
		
		$volatile $call addr_gen (buffer_index y_index) (mem_addr) 
		data := eth_payload
		$split (data 1 64 8) (tlast tdata tkeep)
		$volatile req := ($concat $zero<1> $one<1> tkeep mem_addr tdata)
		request_pipe := req
		
		//resp := response_pipe
		y_next :=  (y_index + 1)
		
		$if(~tlast) $then
			$place[loopback]
		$endif
		
		bad_packet := ((tdata == _hffffffffffffffff) & (tkeep == 0))
		
		end_y_index := y_index

		last_keep := tkeep
		
		done := $one<1>
		 
	}	
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// addr_gen

// Inputs : buffer_index
//	    y_index
	

// Outputs : mem_addr

$volatile $module [addr_gen]
	$in(buffer_index : $uint<9> y_index : $uint<12>)
	$out(mem_addr : $uint<36>)
$is
{
	// Need to review this as there may some issues
	// of size missmatch.
	buf_index_cast := ($bitcast ($uint<12>) buffer_index)
	intm_calc := ((buf_index_cast * Y_LIMIT) + (y_index * 8))
	intm_calc_cast := ($bitcast ($uint<36>) intm_calc)
	mem_addr := (BUFFER_OFFSET + intm_calc_cast)
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Calculate next state 
// Inputs : Current State
//          done_0 done_1 done_2
// Outputs : New state

$volatile $module [calc_next_state]
    $in (BAD_PACKET : $uint<1>
		 done_0 : $uint<1>
         done_1 : $uint<1>
         done_2 : $uint<1>
         curr_state : $uint<2>)
    
    $out (next_state : $uint<2>)

    $is
    {
	cond_1 := ((curr_state == S0) & ((done_0 == 1) | (BAD_PACKET == 1)))
	cond_2 := ((curr_state == S1) & done_1)
	cond_3 := ((curr_state == S2) & done_2)

        next_state := ($excmux cond_1 S1 cond_2 S2 cond_3 S0)

    }





$module [writeFlag]
	$in(buf_index : $uint<9> 
		packet_status : $uint<1> // 1 bad packet 0 good
		y_index : $uint<12>
		last_keep : $uint<8>
		)
	$out(done_2 : $uint<1>)
$is
{

	flag_data :=  ($bitcast ($uint<8>) _b10000000)
	flag := ($mux packet_status  $zero<8> flag_data)

	$volatile $call addr_gen (buf_index 0) (mem_addr)

	request_data := ($concat ($bitcast ($uint<36>)_h000000000) y_index last_keep flag)

	request_pipe :=  ($concat $zero<1> $zero<1> ($bitcast ($uint<8>) _hff) mem_addr request_data) $mark REQUEST

	response_data := response_pipe $synch (REQUEST)

	done_2 := $zero<1>
	
	
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$module [receiverDaemon] $in () $out () $is
{
	$branchblock[main]
	{
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi curr_state_main := S0 $on $entry next_state $on $loopback
			$phi BAD_PACKET := $one<1> $on $entry bad_packet_prev $on $loopback
			$phi buf_index := $zero<9> $on $entry new_buffer_index $on $loopback
		$endmerge

     		state0_cond_1 := (curr_state_main == S0)       
		$guard(state0_cond_1)
			$call getBufLocation (BAD_PACKET buf_index) (new_buffer_index)
            
		state0_cond2 := ((curr_state_main == S0) & (~BAD_PACKET))
		$guard (state0_cond2)
			$call checkEmptyBuf (new_buffer_index) (done_0)
            

		// State 1 here
		state1_cond1 := (curr_state_main == S1)		
		$guard(state1_cond1)
			$call write_eth_header_to_mem (buf_index) (header_write_done_1)

		a := (curr_state_main == S1)
		b := header_write_done_1

		state1_cond2 := (a & b)
		
		$guard(state1_cond2)
			$call write_eth_payload_to_mem (buf_index) (end_y_index done_1 bad_packet_prev last_keep)	

		state2_cond := (curr_state_main == S2)
		// State 2 here
		$guard (state2_cond)
			$call writeFlag (buf_index BAD_PACKET end_y_index last_keep) (done_2)
		

		//Calculate Next State

		$volatile $call calc_next_state (BAD_PACKET done_0 done_1 done_2 curr_state_main) (next_state)

		$while 1
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

