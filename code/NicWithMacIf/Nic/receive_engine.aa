//
// States
//    INIT_STATE
//        initialize things in this state.
// 
//    CHECK_AND_GET_BUF_STATE
//		In this state, we will call a function which
//		identifies if the next buffer is available.
//
//    LOAD_BUF_STATE
//		In this state, data from the parser pipe is 
//		written into the available buffer.
//
//    WRITE_FLAGS
//              In this state, we will write flags into
//		the flag area of the buffer control word.
// 

// Pipe Declarations


// Pipes from Parser
$pipe eth_header     : $uint<73>  $depth   5
$pipe eth_payload    : $uint<73>  $depth 128


//Pipes to Memory
$pipe request_pipe   : $uint<110> $depth 128  
$pipe response_pipe  : $uint<65>  $depth 128


// Pipes to TestBench



//Constant Declarations
$constant THREE: $uint<12> := 3
$constant Y_LIMIT : $uint<12> := 1544
$constant BUFFER_OFFSET : $uint<36> := 0


//Empty Buffer Location Pipe
$pipe empty_buf_pipe : $uint<12> $depth 10


// Storage Variables


// Helper Modules

// Address Generator
$volatile $module [addr_gen]
	$in(buffer_index : $uint<12> y_index : $uint<12>)
	$out(mem_addr : $uint<36>)
$is
{
	// Need to review this as there may some issues
	// of size missmatch.
	buf_index_cast := ($bitcast ($uint<12>) buffer_index)
	intm_calc := ((buf_index_cast * Y_LIMIT) + (y_index * 8))
	intm_calc_cast := ($bitcast ($uint<36>) intm_calc)
	mem_addr := (BUFFER_OFFSET + intm_calc_cast)
}

//Delay Block
$operator $module [delay_time]
	$in (T: $uint<32>) $out (delay_done : $uint<1>) $is
{
	$branchblock[loop] {
	    $dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi R := T $on $entry nR $on $loopback
		$endmerge

		$volatile nR := (R - 1)
	   $while (R > 0)

	   $volatile delay_done := 1
	}
}





//Empty Buffer Checker
$module [CheckEmptyBuf] $in(buf_index : $uint<12>) $out(new_buf_index : $uint<12>)
$is
{
	$branchblock [main]
        {
            $merge $entry loopback
		$phi wait_req := $one<1> $on $entry
			    ($call delay_time (30)) $on loopback
            $endmerge

            $volatile $call addr_gen (buf_index 0) (mem_addr) 
            $volatile request_data := ($concat $zero<1> $one<1> ($bitcast ($uint<8>) _hff) 						mem_addr ($bitcast ($uint<64>) _h0000000000000000))
	    

	    $if(wait_req == 1) $then

		request_pipe := request_data
		response_data := response_pipe

	    	$volatile flag := ($slice response_data 7 0)
            	$volatile isBufEmpty := (flag == 0)

		$if (~isBufEmpty) $then
                	$place [loopback] 
		$endif
	    $endif

	    new_buf_index := buf_index
	

	}
		
}

// Write Ethernet Header to Memory
$module [write_eth_header_to_mem]
	$in(buffer_index : $uint<12>)
	$out(header_write_status : $uint<1>)
$is
{
	$volatile $call addr_gen (buffer_index 1) (mem_addr1) 
	data1 := eth_header
	$split (data1 1 64 8)(tlast1 tdata1 tkeep1)
	$volatile req_1 := ($concat $zero<1> $one<1> tkeep1 mem_addr1 tdata1 )
	request_pipe := req_1

	
	$volatile $call addr_gen (buffer_index 2) (mem_addr2) 
	data2 := eth_header
	$split (data2 1 64 8)(tlast2 tdata2 tkeep2)
	$volatile req_2 := ($concat $zero<1> $one<1> tkeep2 mem_addr2 tdata2 )
	request_pipe := req_2
	
	
	$volatile header_write_status := $one<1>
} 


// Writes Payload from Parser and writes to Memory
$module [write_eth_payload_to_mem]
	$in(buffer_index : $uint<12>)
	$out(end_y_index:$uint<12> 
	     bad_packet : $uint<1> 
	     last_keep : $uint<8>)
$is
{
	$branchblock[main]
	{
		$merge $entry loopback
			$phi y_index := THREE $on $entry y_next $on loopback
		$endmerge
		
		$volatile $call addr_gen (buffer_index y_index) (mem_addr) 
		data := eth_payload
		$volatile $split (data 1 64 8) (tlast tdata tkeep)
		$volatile req := ($concat $zero<1> $one<1> tkeep mem_addr tdata)
		request_pipe := req
		
		//resp := response_pipe
		$volatile y_next :=  (y_index + 1)
		
		$if(~tlast) $then
			$place[loopback]
		$endif
		
		$volatile bad_packet := ((tdata == _hffffffffffffffff) & (tkeep == 0))
		
		$volatile end_y_index := y_index

		$volatile last_keep := tkeep
		
		 
	}	
}



$module [loadBuffer] 
	$in(buf_index : $uint<12>)
	$out(load_buffer_status : $uint<21>)

$is
{

	$call write_eth_header_to_mem (buf_index) (header_write_status)

	$guard(header_write_status)
		$call write_eth_payload_to_mem (buf_index) (end_y_index bad_packet last_keep)

	$volatile load_buffer_status := ($concat end_y_index bad_packet last_keep) 
	
}


$module [writeFlag]
	$in(	buf_index : $uint<12> 
		load_buf_status : $uint<21>
	   )
	$out(bad_packet : $uint<1>)
$is
{

	$volatile $split(load_buf_status 12 1 8) (y_index packet_status last_keep)

	$volatile flag_data :=  ($bitcast ($uint<8>) _b10000000)
	$volatile flag := ($mux packet_status  $zero<8> flag_data)

	$volatile $call addr_gen (buf_index 0) (mem_addr)

	$volatile request_data := ($concat ($bitcast ($uint<36>)_h000000000) y_index last_keep flag)

	request_pipe :=  ($concat $zero<1> $zero<1> ($bitcast ($uint<8>) _hff) mem_addr 			       request_data)

	

	$volatile bad_packet := packet_status
	
	
}


$module [receiverDaemon] $in () $out () $is
{

	$branchblock[main]
	{
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback 

			$phi buffer_index := $zero<12> $on $entry 
					     $guard(~packet_status)
						(buffer_index + 1)   $on $loopback  

		$endmerge

   		       $call CheckEmptyBuf (buffer_index) (empty_buffer_index)
		       $call loadBuffer (empty_buffer_index) (load_buffer_status)
		       $call writeFlag (empty_buffer_index load_buffer_status) (packet_status)

		$while 1
	}
}

