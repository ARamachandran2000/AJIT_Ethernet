// This Module is responsible for reading the payload and the 
// ethernet header from the parser and sends it to memory


// States : 
// 1. Check Empty Buffer
// 2. Read from Parser and write to memory
// 3. Check if it is a bad packet based on last word

// TODO : Need to ask sir How memory interface works.

// Notes : If it is a bad packet then next packet can be loaded in the same location i.e no need to send
// request to memory.

//////////////////////////////////Global Variables//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$constant S0: $uint<2> := 0 // Empty Buffer Finding state
$constant S1: $uint<2> := 1 // Stores payload and header in memory
$constant S2: $uint<2> := 2 // Packet status checker and sets flag if good packet



$pipe request_pipe   : $uint<110> $depth 128  
$pipe response_pipe  : $uint<65>  $depth 128  
$pipe eth_header     : $uint<73>  $depth   5
$pipe eth_payload    : $uint<73>  $depth 128

$constant THREE: $uint<11> := 3
$constant Y_LIMIT : $uint<12> := 1544
$constant BUFFER_OFFSET : $uint<36> := 0

$volatile $module [checkEmptyBuf]
    $in (buf_index : $uint<9>)
    $out(done : $uint<1>)

    $is
    {
        $branchblock [main]
        {
            $merge $entry loopback

            $endmerge

         	$volatile $call addr_gen (buf_index 0) (mem_addr) 
            request_data := ($concat zero<1> one<1> _hff mem_addr _h0000000000000000) $mark WAIT

			// Wait 30 clock cycles between requests            

            request_pipe := request_data $delay (WAIT 30)
            
            response_data := response_pipe
			flag := ($slice response_data 7 0)
            isBufEmpty := (flag == 0)

            $if (~isBufEmpty) $then
                $place [loopback] // put token in place "loopback"
            $endif

            done := ( $mux (isBufEmpty)  (one<1>) (zero<1>))

        }

    }


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get bufLocation

// Inputs : 
//          Bad Packet status
//          previous buffer index

// Outputs : New Buffer Index (based on bad packet status)


$volatile $module [getBufLocation] 
    $in(bad_packet_status : $uint<1>
        prev_buffer_index : $uint<9> )
    
    $out(
        new_buffer_index : $uint<9>    
        )
    $is
    {
        
        $volatile new_buffer_index := ($mux bad_packet_status 
        					prev_buffer_index 
        					(prev_buffer_index + 1))

    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// write_eth_header_to_mem

// Inputs : buffer_index
	

// Outputs : header_write_done

$volatile $module [write_eth_header_to_mem]
	$in(buffer_index : $uint<9>)
	$out(header_write_done : $uint<1>)
$is
{
	$volatile $call addr_gen (buffer_index 1) (mem_addr1) 
	data1 := eth_header
	$split (data1 1 64 8)(tlast1 tdata1 tkeep1)
	$volatile req_1 := ($concat zero<1> one<1> tkeep1 mem_addr1 tdata1 )
	request_pipe := req_1
	//response1 := response_pipe
	
	$volatile $call addr_gen (buffer_index 2) (mem_addr2) 
	data2 := eth_header
	$split (data2 1 64 8)(tlast2 tdata2 tkeep2)
	$volatile req_2 := ($concat zero<1> one<1> tkeep2 mem_addr2 tdata2 )
	request_pipe := req_2
	//response2 := response_pipe
	
	$volatile header_write_done := $one<1>
} 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// write_eth_payload_to_mem

// Inputs : buffer_index
	

// Outputs : done

$volatile $module [write_eth_payload_to_mem]
	$in(buffer_index : $uint<9>)
	$out(end_y_index:$uint<12> done, bad_packet : $uint<1> last_keep : $uint<8>)
$is
{
	$barnchblock[main]
	{
		$merge $entry loopback
			$phi y_index := THREE $on $entry y_next $on loopback
		$endmerge
		
		$volatile $call addr_gen (buffer_index y_index) (mem_addr) 
		data := eth_payload
		$split (data 1 64 8) (tlast tdata tkeep)
		$volatile req := ($concat $zero<1> $one<1> tkeep mem_adder tdata)
		request_pipe := req
		
		//resp := response_pipe
		y_next :=  (y_index + 1)
		
		$if(~t_last) $then
			$place[loopback]
		$endif
		
		bad_packet := ((tdata == _hffffffffffffffff) & (tkeep == 0))
		
		end_y_index := y_index

		last_keep := tkeep
		
		done := $one<1>
		 
	}	
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// addr_gen

// Inputs : buffer_index
//	    y_index
	

// Outputs : mem_addr

$volatile $module [addr_gen]
	$in(buffer_index : $uint<9> y_index : $uint<11>)
	$out(mem_addr : $uint<36>)
$is
{
	// Need to review this as there may some issues
	// of size missmatch.
	mem_addr := ((BUFFER_OFFSET + (buffer_index * Y_LIMIT)) + (y_index * 8))
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Calculate next state 
// Inputs : Current State
//          done_0 done_1 done_2
// Outputs : New state

$volatile $module [calc_next_state]
    $in (BAD_PACKET : $uint<1>
		 done_0 : $uint<1>
         done_1 : $uint<1>
         done_2 : $uint<1>
         curr_state : $uint<2>)
    
    $out (next_state : $uint<2>)

    $is
    {
        next_state := ($excmux
                ((curr_state == S0) & ((done_0 == 1) | (BAD_PACKET == 1))   S1
                ((curr_state == S1) & done_1)   							S2
                ((curr_state == S2) & done_2)   							S0)

    }





$volatile $module [writeFlag]
	$in(buf_index : $uint<9> 
		packet_status : $uint<1> // 1 bad packet 0 good
		y_index : $uint<12>
		last_keep : $uint<8>
		)
	$out(done_2 : $uint<1>)
$is
{

	flag := ( $mux (packet_status)  (zero<8>) (_b10000000))
	$volatile $call addr_gen (buf_index 0) (mem_addr)

	request_data := ($concat _h000000000 y_index last_keep flag)

	request_pipe :=  ($concat $zero<1> $zero<1> _hff mem_adder request_data) $mark REQUEST

	response_data := response_pipe $synch (REQUEST)

	done_2 := one<1>
	
	
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

$module [receiverDaemon] $in () $out () $is
{
	$branchblock[main]
	{
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi curr_state_main := S0 $on $entry next_state $on $loopback
			$phi BAD_PACKET := $one<1> $on $entry bad_packet_prev $on $loopback
			$phi buf_index := $zero<9> $on $entry new_buffer_index $on $loopback
		$endmerge

            
		$guard(curr_state_main == S0)
			$volatile $call getBufLocation (BAD_PACKET buf_index) (new_buffer_index)
            
		$guard ((curr_state_main == S0) & (~BAD_PACKET))
			$volatile $call checkEmptyBuf (new_buffer_index) (done_0)
            

		// State 1 here
		$guard(curr_state_main == S1)
			$volatile $call write_eth_header_to_mem (buf_index) (header_write_done_1)
		
		$guard((curr_state_main == S1) & (header_write_done_1))
			$volatile $call write_eth_payload_to_mem (buf_index) (end_y_index done_1 bad_packet_prev last_keep)	


		// State 2 here
		$guard (curr_state_main == S2)
			$volatile $call writeFlag (buf_index BAD_PACKET end_y_index last_keep) (done_2)
		

		//Calculate Next State

		$call calc_next_state (BAD_PACKET done_0 done_1 done_2 curr_state_main) (next_state)

		$while 1
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

