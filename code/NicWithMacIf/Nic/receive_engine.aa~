// Receives the header and packet data from the Parser and stores it in Memory...


// Step 1 : Get Free Buffer Pointer from Free Queue
// Step 2 : Write the packet data into the acquired free buffer
// Step 3 : Write the buffer pointer into one of the Rx Queues pointed  by RxQ register (Do this
// Sequentilly so that a particular server is not overburdened.
// Step 4 : Repeat Steps 1-3 for the next packet


// Main Daemon that repeatedly executes Steps 1-3 above
$module [ReceiveEngineDaemon] 
$in ()
$out()
$is
{
	$branchblock[main]
	{
		// loop around until enabled by Software
		$merge $entry not_enabled_yet_loopback disable_loopback $endmerge
	
		// If not enabled yet -> Loopback
		$if (~ (CONTROL_WORD [] 0)) $then
			$place [not_enabled_yet_loopback]
		$endif

		// Once enabled start processing
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback 
			// Used to Indicate which server's Queue to write to
			$phi q_index := $zero<6> $on $entry 
					((q_index + 1) & (NUM_OF_SERVERS-1)) $on $loopback
		
		$endmerge

		// Step 1 : Pop From Free Queue -> If not empty (Success indicated by status) 
		popFromQueue (FREE_Q) (rx_buffer_pointer_32 status)
		// Get the free buffer pointer in rx_buffer_pointer
		
		// convert 32 bit virtual address to 36 bit physical address.
		// Should memory address be used with Disabled MMU ??.... 
		// If this is the case then set MSB 4 bits to 0 to make physical address
		// Make address DoubleWord Aligned by setting last 3 bits to 0
		// TODO : Clarify this!!
		$volatile rx_buffer_pointer_36 := ($bitcast ($uint<36>) ($slice rx_buffer_pointer_32 31 1) $zero<3>)
		
		// Step 2 : If pop was successful then start loading the buffer
		$guard (status)
			$call loadBuffer (rx_buffer_pointer_36) (bad_packet_identifier)

		// Step 3
		// If the packet is not a bad packet then write the rx_buffer_pointer to the 
		// RX Queue
		// If bad packet is 1 then repurpose the buffer by pushing it back to Free Q
		$if(~bad_packet_identifier) $then
			$call populateRxQueue (rx_buffer_pointer q_index) ()
		$else
			$call pushPointerBackToFreeQ (FREE_Q rx_buffer_pointer) () 
		$endif
		// Loop while Control word is 0
		$while (CONTROL_WORD [] 0)
			$place [disable_loopback]
	}
}





// Load into the Buffer starting from Buffer Index 1...
// Buffer Index 0 is reserved for control information of the packet following it
// Steps : 
// First Store the Ethernet Header information in the buffer
// Then, store the IP payload into the buffer
// Finally Add the Control Information at the base address pointer (index = 0) if the packet
// currently being stored is not a bad packet
$module [loadBuffer]
$in (rx_buffer_pointer : $uint<36>)
$out(bad_packet_identifier : $uint<1>)
$is
{
	// Read from Ethernet Header Pipe and stores into memory 
	// Returns the last pointer location which was written to
	$call writeEthernetHeaderToMem (rx_buffer_pointer) (new_buf_pointer)

	// Read from Ethernet Payload Pipe and stores in memory starting from the last written
	// pointer location
	// Returns the Control information like -> Packet Size, BAd packet Status and 
	// byte mask of last word
	$call writePayloadToMem (rx_buffer_pointer new_buf_pointer)
				(packet_size bad_packet_identifier last_keep)

	// Write Control Information to Memory if not a bad packet
	// If it IS a bad packet don't bother writing since the buffer will be repurposed
	// for the next packet 
	$guard(~bad_packet_identifier)
		$call writeControlInformationToMem (rx_buffer_pointer packet_size  last_keep) ()

}

// Write Ethernet Header to Buffer
$module [writeEthernetHeaderToMem]
$in (buf_pointer : $uint<36>)
$out()
$is
{
	$merge $entry loopback
			// Write from buffer index 1 i.e (buf_pointer + 8), since ...
			// index = 0 i.e location buf_pointer is reserved for control
			//information
		$phi buf_position := (buf_pointer + 8) $on $entry
				     (buf_position + 8) $on loopback
					// After storing a packet increment buf_position to
					// next index
		$phi I := 0 $on $entry nI $on loopback 
		// Ethernet Header is only 2 words, therefore a counter to keep track of count
	$endmerge
	
	// Read Header word from pipe
	ethernet_header := nic_rx_to_header

	// Extract individual components of the word 
	$volatile $split (ethernet_header 1 64 8)(last_bit wdata wkeep)
	
	// Write the data to memory with bmask->wkeep at location buf_position
	$call accessMemory ($zero<1> $zero<1> wkeep buf_position wdata) 				   (ignore_return) 
	$volatile nI := I + 1

	// If 2 words are stored, then end
	$if(nI <= 1) $then
		$place [loopback]
	$endif

}


// Write Payload Data to Buffer
$module [writePayloadToMem]
	// Base buffer pointer is used to calculate the packet size
	// buf_pointer -> Consists of last written buffer location
$in (base_buf_pointer : $uint<36> buf_pointer : $uint<36>)
$out(packet_size:$uint<12> bad_packet_identifier : $uint<1> last_keep : $uint<8>)
$is
{
	$merge $entry loopback
				// Begin loading from buf_pointer + 8 since buf_pointer
				// has already been written into by Ethernet Header 
		$phi buf_position := (buf_pointer + 8) $on $entry
				     (buf_position + 8) $on loopback
	$endmerge
	
	// Read Data from Payload Pipe
	payload_data := nic_rx_to_packet

	// Extract payload word components
	$volatile $split (payload_data 1 64 8)(last_bit wdata wkeep)
	
	// Load wdata to memory with wkeep = bmask
	$call accessMemory ($zero<1> $zero<1> wkeep buf_position wdata) 			   (ignore_return) 

	// If the word has last-bit set to 1 then entire packet has been stored and do not
	// loopback
	$if(~last_bit) $then
		$place [loopback]
	$endif

	// Identify if the data is a bad packet which is identified by 
	// data bits all 1 and bmask all zeros.
	$volatile bad_packet := ((tdata == BAD_PACKET_DATA) & (tkeep == 0))

	// Calculate packet size which is in multiples of 8-bit words stored
	// Can divide by 8 to get size in 64-bit word multiples
	// Divide by 4 to get size in 32-bit word multiples	
	$volatile packet_size_8 := ($bitcast ($uint<12>) ((buf_position - base_buf_pointer) + 1))
	//$volatile packet_size_32 := (packet_size_8 << 2)

	// bmask of last word is wkeep
	$volatile last_keep := wkeep
	
}

// Write the Control Information of stored packet into buffer location 0
$module [writeControlInformationToMem]
$in (base_buffer_pointer : $uint<36> packet_size:$uint<12>  last_keep : $uint<8>)
$out()
$is
{
	// Concatenate the control information to create control_data
	// This control data is a work in progress.... (Can add other information like 
	// stored by NIC so and so and send to NIC so and so etc.. 
	$volatile control_data := ($bitcast ($uint<64>) ($concat packet_size last_keep))

	// Write this control data with bmask set to all 1s to base_buffer_pointer location
	$call accessMemory ($zero<1> $zero<1> FULL_BYTE_MASK base_buffer_pointer control_data) 				    (ignore_return)


}

///////////////////////////////////////////////////////////////////////////////////////////
// Writes into the RX_Queue of server "q_index" the buffer pointer  
// "rx_buffer_pointer"   
$module [populateRxQueue]
$in (rx_buffer_pointer : $uint<36> q_index : $uint<6>)
$out ()
$is
{
	$branchblock[PushIntoQueue]
	{
		// Rx Queues Index in the Register File start from Index 2
		$volatile register_index := (q_index + 2) 
	
		// Request for Rx Queue Pointer of Server ID : q_index Regsiter ID : q_index + 2
			    	// rwbar bmask       index	     wdata        
		$call AccessRegister (one<1> one<4> register_index zero<32>) (rx_queue_pointer)
	
	
		$merge $entry unsuccessful_push_loopback
		// On Entry No waiting
		// If push is unsuccessful because of full Queue then wait for WAIT_TIME
		// and then retry
		$phi wait_req := $one<1> $on $entry
			    	($call delay_time (WAIT_TIME)) $on unsuccessful_push_loopback
		$endmerge

		// If wait period is over, then push data into the Queue
		$guard(wait_req)
			$call pushIntoQueue (rx_queue_pointer rx_buffer_pointer) (push_status)
					// Queue to push into	// Data to push   
		
		// IF push is unsuccessful then wait for WAIT_TIME and retry
		$if(~push_status) $then
			$place [unsuccessful_push_loopback]
		$endif

	}

}



// Alternate Implementation of "populateRxQueue"
// If a particular server queue is full then do not wait...
// Go to next queue and try there
// Based on Feb8 Weekly Meet .... 
$module [AlternatePopulateRxQueue]
$in (rx_buffer_pointer : $uint<36> q_index : $uint<6>)
$out ()
$is
{
	$branchblock[PushIntoQueue]
	{
		$merge $entry queue_full_loopback

		$phi new_q_index := q_index $on $entry
	 	               ((new_q_index + 1) & (NUM_OF_SERVERS-1)) $on queue_full_loopback
		
		$endmerge
		// Rx Queues Index in the Register File start from Index 2
		$volatile register_index := (new_q_index + 2) 
	
		// Request for Rx Queue Pointer of Server ID : q_index Regsiter ID : q_index + 2
			    	// rwbar bmask       index	     wdata        
		$call AccessRegister (one<1> one<4> register_index zero<32>) (rx_queue_pointer)
	

		// Try to push data into the Queue
		$call pushIntoQueue (rx_queue_pointer rx_buffer_pointer) (push_status)
					// Queue to push into	// Data to push   
		
		// IF push is unsuccessful then retry with next server q 
		$if(~push_status) $then
			$place [queue_full_loopback]
		$endif

	}

}
/////////////////////////////////////////////////////////////////////////////////////
