// Receives the header and packet data from the Parser and stores it in Memory...


// Step 1 : Get Free Buffer Pointer from Free Queue
// Step 2 : Write the packet data into the acquired buffer
// Step 3 : Write the buffer pointer into one of the Rx Queues pointed  by RxQ register
// Step 4 : Repeat Steps 1-3 for next packet

// Constant Declarations
$constant WAIT_TIME: $uint<10> := 10 // Wait for WAIT_TIME number of clock cycles
$constant FULL_BYTE_MASK : $uint<8> := _b11111111
$constant BAD_PACKET_DATA : $uint<64> := _hffffffffffffffff

$module [ReceiveEngineDaemon] 
$in ()
$out()
$is
{
	$branchblock[main]
	{
		// loop around until enabled
		$merge $entry not_enabled_yet_loopback disable_loopback $endmerge
	
		$if (~ (CONTROL_WORD [] 0)) $then
			$place [not_enabled_yet_loopback]
		$endif

		$dopipeline $depth 7 $fullrate

		$merge $entry $loopback 
			$phi q_index := $zero<6> $on $entry 
					((q_index + 1) & (NUM_OF_SERVERS-1)) $on $loopback
		
		$endmerge

		// Step 1 : Pop From Free Queue -> If not empty (Success indicated by status) 
		popFromQueue (FREE_Q) (rx_buffer_pointer status)
		
		// If pop was successful then start loading the buffer
		$guard (status)
			$call loadBuffer (rx_buffer_pointer) (bad_packet_identifier)

		// If both the previous stages are completed , then indicate to the server by 
		// by populating the Rx Queue with the buffer pointer

		$if(~bad_packet_identifier) $then
			$call populateRxQueue (rx_buffer_pointer q_index) ()
		$else
			$call pushPointerBackToFreeQ (FREE_Q rx_buffer_pointer) () 
		$endif

		$while (CONTROL_WORD [] 0)

		$place [disable_loopback]
	}
}





// Load into the Buffer starting from Buffer Index 1...
// Buffer Index 0 is reserved for control information of the packet following it
// Steps : 
// First Store the Ethernet Header information in the buffer
// Then, store the IP payload into the buffer
// Finally Add the Control Information at the base address pointer (index = 0) and return
$module [loadBuffer]
$in (rx_buffer_pointer : $uint<36>)
$out(bad_packet_identifier : $uint<1>)
$is
{
	$call writeEthernetHeaderToMem (rx_buffer_pointer) (new_buf_pointer)

	$call writePayloadToMem (rx_buffer_pointer new_buf_pointer)
				(packet_size bad_packet_identifier last_keep)

	// Write Control Information to Memory
	$guard(~bad_packet_identifier)
		$call writeControlInformationToMem (rx_buffer_pointer packet_size  last_keep) ()

}


$module [writeEthernetHeaderToMem]
$in (buf_pointer : $uint<36>)
$out()
$is
{
	$merge $entry loopback
		$phi buf_position := buf_pointer $on $entry
				     (buf_position + 8) $on loopback
		$phi I := 0 $on $entry nI $on loopback 
	$endmerge

	ethernet_header := nic_rx_to_header
	$volatile $split (ethernet_header 1 64 8)(last_bit wdata wkeep)
	$call accessMemory ($zero<1> $zero<1> wkeep buf_position wdata) 				   (ignore_return) 
	$volatile nI := I + 1

	$if(nI <= 1) $then
		$place [loopback]
	$endif

}

$module [writePayloadToMem]
$in (base_buf_pointer : $uint<36> buf_pointer : $uint<36>)
$out(packet_size:$uint<12> bad_packet_identifier : $uint<1> last_keep : $uint<8>)
$is
{
	$merge $entry loopback
		$phi buf_position := (buf_pointer + 8) $on $entry
				     (buf_position + 8) $on loopback
	$endmerge

	payload_data := nic_rx_to_packet
	$volatile $split (payload_data 1 64 8)(last_bit wdata wkeep)
	$call accessMemory ($zero<1> $zero<1> wkeep buf_position wdata) 			   (ignore_return) 


	$if(~last_bit) $then
		$place [loopback]
	$endif

	$volatile bad_packet := ((tdata == BAD_PACKET_DATA) & (tkeep == 0))
		
	$volatile packet_size := ($bitcast ($uint<12>) (buf_position - base_buf_pointer))

	$volatile last_keep := wkeep
	
}

$module [writeControlInformationToMem]
$in (base_buffer_pointer : $uint<36> packet_size:$uint<12>  last_keep : $uint<8>)
$out()
$is
{

	$volatile control_data := ($bitcast ($uint<64>) ($concat packet_size last_keep))


	$call accessMemory ($zero<1> $zero<1> FULL_BYTE_MASK base_buffer_pointer control_data) 				    (ignore_return)


}


$module [pushPointerBackToFreeQ]
$in(queue_base_address : $uint<36> pointer_to_push : $uint<36>)
$out()
$is
{
		$merge $entry unsuccessful_push_loopback
		$phi wait_req := $one<1> $on $entry
			    	($call delay_time (WAIT_TIME)) $on unsuccessful_push_loopback
		$endmerge

		// If wait period is over, then push data into the Queue
		$guard(wait_req)
			$call pushIntoQueue (queue_base_address pointer_to_push) (push_status)
					// Queue to push into	// Data to push   
		
		// IF push is unsuccessful then wait for WAIT_TIME and retry
		$if(~push_status) $then
			$place [unsuccessful_push_loopback]
		$endif
}



// Writes into the RX_Queue of server "q_index" the buffer pointer  
// "rx_buffer_pointer"   
$module [populateRxQueue]
$in (rx_buffer_pointer : $uint<36> q_index : $uint<6>)
$out ()
$is
{
	$branchblock[PushIntoQueue]
	{
		// Rx Queues Index in the Register File start from Index 2
		$volatile register_index := (q_index + 2) 
	
		// Request for Rx Queue Pointer of Server ID : q_index Regsiter ID : q_index + 2
			    	// rwbar bmask       index	     wdata        
		$call AccessRegister (one<1> one<4> register_index zero<32>) (rx_queue_pointer)
	
	
		$merge $entry unsuccessful_push_loopback
		$phi wait_req := $one<1> $on $entry
			    	($call delay_time (WAIT_TIME)) $on unsuccessful_push_loopback
		$endmerge

		// If wait period is over, then push data into the Queue
		$guard(wait_req)
			$call pushIntoQueue (rx_queue_pointer rx_buffer_pointer) (push_status)
					// Queue to push into	// Data to push   
		
		// IF push is unsuccessful then wait for WAIT_TIME and retry
		$if(~push_status) $then
			$place [unsuccessful_push_loopback]
		$endif

	}

}
