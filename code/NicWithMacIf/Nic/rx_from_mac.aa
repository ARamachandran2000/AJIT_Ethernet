//
//states :
//	S0 ->	RX := pipe
//		send to header pipe
//		send to payload pipe
//		goto S1
//	S1 ->	RX := pipe
//		send to header pipe (tkeep := 00111111)
//		send to payload pipe
//		goto S2
//	S2 ->	RX := pipe
//		send to payload pipe
//		if(tlast == 1)
//			goto S0
//		else
//			goto S2

$constant S0: $uint<2> := 0
$constant S1: $uint<2> := 1
$constant S2: $uint<2> := 2

$module [nicRxFromMacDaemon] $in () $out () $is
{
	$bramchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
			// where are we in the packet
			// S0	S1	S2
			//start	Header	Payload	
			// local_state
			//	2
				$phi LSTATE := $zero<2> $on $entry nLSTATE $on $loopback
				$phi RX := mac_to_nic_data $on $entry, $loopback
			$endmerge
			
			$rreport(nicRxFromMacDaemon data_is RX LSTATE)
			$volatile $call nextLSTATE (RX LSTATE)	(nLSTATE)
			
			$volatile write_to_header := ((LSTATE == S0) | (LSTATE == S1))
			
			$guard (write_to_header) nic_rx_to_header := ($mux (LSTATE == S1)
										($concat ($slice RX 72 8) HEADER_TKEEP)
										RX)
			nic_rx_to_packet := RX
			
			$volatile nTOTAL_STATE := ($concat nLSTATE)
			$while 1
	}
}

$volatile $module [nextLSTATE]
	$in (RX : $uint<73> LSTATE : $uint<2> )
	$out(nLSTATE : $uint<2>)
$is
{
	$volatile $split(RX 1 64 8) (tlast tdata tkeep)
	$volatile last_word := (tlast == 1)
	nLSTATE := ($excmux
			(LSTATE == S0) 			S1
			(LSTATE == S1) 			S2
			((LSTATE == S2) & (~last_word))	S2
			((LSTATE == S2) & last_word)	S0)
}

