//
//states :
//	S0 ->	RX := pipe
//		send to header pipe
//		send to payload pipe
//		goto S1
//	S1 ->	RX := pipe
//		send to header pipe (tkeep := 00111111)
//		send to payload pipe
//		goto S2
//	S2 ->	RX := pipe
//		send to payload pipe
//		if(tlast == 1)
//			goto S0
//		else
//			goto S2

$constant S0: $uint<2> := 0
$constant S1: $uint<2> := 1
$constant S2: $uint<2> := 2
//$constant S3: $uint<2> := 3

$module [nicRxFromMacDaemon] $in () $out () $is
{
	$bramchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
			// where are we in the packet
			// S0	S1	S2
			//start	Header	Payload	
			// local_state
			//	2
				$phi LSTATE := $zero<2> $on $entry nLSTATE $on $loopback
				$phi RX := mac_to_nic_data $on $entry, $loopback
			$endmerge
			
			$rreport(nicRxFromMacDaemon data_is RX LSTATE)
			$volatile $call nextLSTATE (RX LSTATE)	(nLSTATE)
			
			$volatile write_to_header := ((LSTATE == S0) | (LSTATE == S1))
			
			$guard (write_to_header) nic_rx_to_header := RX
			nic_rx_to_packet := RX
			
			$volatile nTOTAL_STATE := ($concat nLSTATE)
			$while 1
	}
}

$volatile $module [nextLSTATE]
	$in (RX : $uint<73> LSTATE : $uint<2> )
	$out(nLSTATE : $uint<2>)
$is
{
	$volatile $split(RX 1 64 8) (tlast tdata tkeep)
	$volatile last_word := (tlast == 1)
	nLSTATE := ($excmux
			(LSTATE == S0) 			S1
			(LSTATE == S1) 			S2
			((LSTATE == S2) & (~last_word))	S2
			((LSTATE == S2) & last_word)	S0)
}


////////////////////////////////////////////////////////

// This module is a simple connection link between tb
//	and actual hardware.
// Reads 64 bit wide pipe(which is written by tb),
//	removes unwanted bits and writes to input pipe
//	of actual hardware.

////////////////////////////////////////////////////////
$module [read_from_tb] $in() $out()
$is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi idata0 := tb_to_nic_parser0 $on $entry,$loopback
				$phi idata1 := tb_to_nic_parser1 $on $entry,$loopback
			$endmerge
			send_data  := ($concat ($slice idata1 8 0) idata0)
			mac_to_nic_data := send_data
		$while 1
	}
}
////////////////////////////////////////////////////////

// This module is a simple connection link between tb
//	and actual hardware.
// Reads 37 bit wide pipe(which is written by HW),
//	convertes it to 64 bit data and writes to pipe 
//	which tb reads to check integrity of data.

////////////////////////////////////////////////////////
$module [send_header_to_tb] $in() $out()
$is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi rhdata := nic_rx_to_header $on $entry, $loopback
			$endmerge
			nic_parser_to_tb_header0 := ($slice rhdata 63 0)
			nic_parser_to_tb_header1 := ($bitcast ($uint<16>) ($slice rhdata 72 64))	
		$while 1
	}
}
$module [send_packet_to_tb] $in() $out()
$is
{
	$branchblock[loop1]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi rpdata := nic_rx_to_packet $on $entry, $loopback
			$endmerge
			nic_parser_to_tb_packet0 := ($slice rpdata 63 0)
			nic_parser_to_tb_packet1 := ($bitcast ($uint<64>) ($slice rpdata 72 64))
		$while 1
	}
}
