//
//states :
//	S0 ->	RX := pipe
//		send to header pipe
//		send to payload pipe
//		goto S1
//	S1 ->	RX := pipe
//		payload length := RX[47:32]
//		send to header pipe (tkeep := 00111111)
//		send to payload pipe
//		Payload_length = payload_length - 2
//		goto S2
//	S2 ->	RX := pipe
//		if(payload_length > 8)
//			send to payload pipe
//			Payload_length = payload_length - 8
//			goto S2
//		else
//			send to payload pipe
//			Payload_length = 0
//			goto S3
//	S3 ->	RX := pipe
//		if(RX == BAD_PAKET_FORMAT)
//			send to payload pipe
//			goto S0
//		else
//			send to header pipe
//			send to payload pipe
//			goto S1

$constant S0: $uint<2> := 0
$constant S1: $uint<2> := 1
$constant S2: $uint<2> := 2
$constant S3: $uint<2> := 3

$module [nicRxFromMacDaemon] $in () $out () $is
{
	$bramchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
			// where are we in the packet
			// S0	S1	S2	S3
			//start	Header	Payload	Bad_packet or New_packet
			// local_state	payload_length
			//	2		16
				$phi TOTAL_STATE := $zero<18> $on $entry nTOTAL_STATE $on $loopback
				$phi RX := mac_to_nic_data $on $entry, $loopback
			$endmerge
			
			$volatile $split (TOTAL_STATE 2 16)
				(LSTATE PLEN)
			
			$rreport(nicRxFromMacDaemon data_is RX TOTAL_STATE LSTATE PLEN)
			$volatile $call nextLSTATE (RX LSTATE PLEN)
					(nLSTATE nPLEN)
			
			$volatile write_to_header := ((LSTATE == S0) | (LSTATE == S1))
			$guard (write_to_header) nic_rx_to_header := RX
			nic_rx_to_packet := RX
			
			$volatile nTOTAL_STATE := ($concat nLSTATE nPLEN)
			$while 1
	}
}

$volatile $module [nextLSTATE]
	$in (RX : $uint<73> LSTATE : $uint<2> PLEN : $uint<16>)
	$out(nLSTATE : $uint<2> nPLEN : $uint<16>)
$is
{
	$volatile valid_plen := (PLEN > 8)
	$volatile $split(RX 1 64 8) (tlast tdata tkeep)
	$volatile bad_packet := (( (tlast == $one<1>) & (tdata == _hFFFFFFFFFFFFFFFF) ) & (tkeep == _h00) )
	nLSTATE := ($excmux
			(LSTATE == S0) 			S1
			(LSTATE == S1) 			S2
			((LSTATE == S2) & valid_plen) 	S2
			((LSTATE == S2) & (~valid_plen))S3
			((LSTATE == S3) & bad_packet)	S0
			((LSTATE == S3) & (~bad_packet))S1)
			
	nPLEN := ($mux	((nLSTATE == S2) | (nLSTATE == S3))
			($mux (LSTATE == S1)
				(($slice RX 47 32) - 2)
				($mux valid_plen (PLEN - 8) 0))
			)	
}


////////////////////////////////////////////////////////

// This module is a simple connection link between tb
//	and actual hardware.
// Reads 64 bit wide pipe(which is written by tb),
//	removes unwanted bits and writes to input pipe
//	of actual hardware.

////////////////////////////////////////////////////////
$module [read_from_tb] $in() $out()
$is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi idata0 := tb_to_nic_parser0 $on $entry,$loopback
				$phi idata1 := tb_to_nic_parser1 $on $entry,$loopback
			$endmerge
			send_data  := ($concat ($slice idata1 8 0) idata0)
			mac_to_nic_data := send_data
		$while 1
	}
}
////////////////////////////////////////////////////////

// This module is a simple connection link between tb
//	and actual hardware.
// Reads 37 bit wide pipe(which is written by HW),
//	convertes it to 64 bit data and writes to pipe 
//	which tb reads to check integrity of data.

////////////////////////////////////////////////////////
$module [send_header_to_tb] $in() $out()
$is
{
	$branchblock[loop]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi rhdata := nic_rx_to_header $on $entry, $loopback
			$endmerge
			nic_parser_to_tb_header0 := ($slice rhdata 63 0)
			nic_parser_to_tb_header1 := ($bitcast ($uint<16>) ($slice rhdata 72 64))	
		$while 1
	}
}
$module [send_packet_to_tb] $in() $out()
$is
{
	$branchblock[loop1]{
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi rpdata := nic_rx_to_packet $on $entry, $loopback
			$endmerge
			nic_parser_to_tb_packet0 := ($slice rpdata 63 0)
			nic_parser_to_tb_packet1 := ($bitcast ($uint<64>) ($slice rpdata 72 64))
		$while 1
	}
}
