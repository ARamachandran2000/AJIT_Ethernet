//

//	This module implements dummy proceesor and memory.

//	Task 1 : read req from NIC and send responce,
//	Task 2 : process buffers.


$pipe request_pipe   : $uint<110> $depth 128  
$pipe response_pipe  : $uint<65>  $depth 128

//16 buffers of 1520bytes = 194560 bits = 3040*64bits 
$parameter MEMORY_ADDRESS_RANGE	3040 
$storage Memory : $array[MEMORY_ADDRESS_RANGE] $of $uint<64>

$constant ZERO_4: $uint<4> := 0
$constant PROCESSED_FLAG : $uint<8> := _b11010000
$constant Y_LIMIT : $uint<12> := 1544
$constant BUFFER_OFFSET : $uint<36> := 0

//
//	Reads req pipe and gives responce 
//	Algorithm :
//		Read Req pipe -> REQ := req_pipe
//		rd/wrbar,addr := REQ[108], REQ[99:64]
//		if(rd/wrbar)
//			data := MEMORY[addr]
//			resp_pipe := {1,data}
//		else
//			write_data_to_mem_addr
//			resp_pipe := {1,data}


$module [memoryManagerDaemon] $in () $out () 
$is
{
	$branchblock [main]
	{
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
		$phi req := request_pipe $on $entry, $loopback
		$endmerge
		$volatile $split (req 1 1 8 36 64)(lock rdwrbar byte_mask addr data)
		
		$guard(rdwrbar)
			response_pipe := ($concat $one<1> Memory[addr])
			
		$guard(~rdwrbar)
			$call writeToMemory (addr byte_mask data) (resp)
		$guard(~rdwrbar) 
			response_pipe := ($concat resp data)
		$while 1
	}
}

$module [writeToMemory]
	$in(addr : $uint<36> byte_mask : $uint<8> data : $uint<64>)
	$out(resp : $uint<1>)
$is
{
	old_data := Memory[addr]
	$branchblock [main]
	{
		$merge $entry loopback
		$phi i := 0 $on $entry n_index $on loopback
		$endmerge
		
		write_byte := (byte_mask [] i)
		
		data_to_write := ($mux write_byte 
					(old_data | (data & (_h00000000000000ff << (($bitcast ($uint<64>) i)*8))))
					data_to_write)
		
		n_index := (i + 1)
		$if(n_index >= 8) $then
			$place [loopback]
		$endif
	}(data_to_write => data_to_write)
	Memory[addr] := data_to_write
	resp := $one<1>
}


// Address Generator

$volatile $module [addr_gen]
	$in(buffer_index : $uint<12> y_index : $uint<12>)
	$out(mem_addr : $uint<36>)
    $is
    {

        buf_index_cast := ($bitcast ($uint<12>) buffer_index)
        intm_calc := ((buf_index_cast * Y_LIMIT) + (y_index * 8))
        intm_calc_cast := ($bitcast ($uint<36>) intm_calc)
        mem_addr := (BUFFER_OFFSET + intm_calc_cast)
    }
    
//Delay Block
$operator $module [delay_time]
	$in (T: $uint<32>) $out (delay_done : $uint<1>) $is
{
	$branchblock[loop] {
	    $dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi R := T $on $entry nR $on $loopback
		$endmerge

		$volatile nR := (R - 1)
	   $while (R > 0)

	   $volatile delay_done := 1
	}
}


//
//	The module checks if the buffer is filled
//	if YES : modifies the processed flag.
//	if NO  : Keeps checking till buffer is filled.
//

$module [FindFilledBufferAndProcess]
    $in (buf_index : $uint<12>)
    $out()

    $is
    {
        $branchblock [main]
        {
            $merge $entry loopback
		$phi wait_req := $one<1> $on $entry
			    ($call delay_time (30)) $on loopback
            $endmerge

            
	    $volatile $call addr_gen (buf_index 0) (mem_addr)

	    $if(wait_req == 1) $then
	    
	    	    control_word := Memory[mem_addr]

		    $volatile flag := ($slice control_word 7 0)
		    $volatile filled := (flag == _b10000000)

		    $if (~filled) $then
		        $place [loopback] // put token in place "loopback"
		    $endif
	    $endif
			
	    Memory[mem_addr] := ($concat ($slice control_word 63 8) PROCESSED_FLAG)
        }

    }

//
//	Processes Buffers
//

$module [processPacketsDaemon] $in() $out()
$is
{
	$branchblock[main]
	{
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi buffer_index := $zero<12> $on $entry
					     (buffer_index + 1)   $on $loopback 
		$endmerge

		$call FindFilledBufferAndProcess (buffer_index)()
		$while 1
	}

}
