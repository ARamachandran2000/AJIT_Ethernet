//
// Utilities
//    Pop a uint32_t from the queue.  Return status = 1 on success.
//
$module [popFromQueue]
	$in (lock : $uint<1> q_base_address : $uint<36>) $out (q_r_data: $uint<32> status: $uint<1>)
$is
{
	$guard (lock) $call acquireMutex(q_base_address) (m_ok)
	$barrier
	
	$call getQueuePointers (q_base_address) (write_index read_index)
	$volatile q_empty := (write_index == read_index)

	$call getQueueLength(q_base_address) (Queue_Length)
	$volatile round_off := (read_index == (Queue_Length - 1))
	$volatile next_ri := ($mux round_off 0 (read_index + 1))
	
	$guard (~q_empty) $call getQueueElement (q_base_address read_index) (q_r_Data)
	$guard (!q_empty) $call setQueuePointers (q_base_address write_index next_ri)
	$rreport(popFromQueue pop_data q_base_address q_r_data q_empty write_index read_index next_ri)

	$barrier
	$guard(lock) $call releaseMutex (q_base_address) ()
	status := q_empty // 0 = success, 1 = Fail
	
}

//
//
// Utilities
//    push a uint32_t into the queue.  Return status = 0 on success.
// 
$module [pushIntoQueue] 
	$in  (lock : $uint<1> q_base_address : $uint<36> q_w_data: $uint<32>) $out (status: $uint<1>)
$is
{
	$guard (lock) $call acquireMutex (q_base_address) (m_ok) 
	$barrier
	$rreport(pushIntoQueue pushing_to_queue q_w_data q_base_address)
	$call getQueuePointers (q_base_address) (write_index read_index)
	
	$call getQueueLength(q_base_address) (Queue_Length)
	$volatile round_off := (read_index == (Queue_Length - 1))
	$volatile next_wi := ($mux round_off 0 (write_index + 1))
	
	$volatile q_full := (next_wi == read_index)
	$rreport(pushIntoQueue pushing_to_queue q_w_data write_index read_index next_wi q_full)
	$guard (~q_full) $call setQueueElement (q_base_address write_index q_w_data) ()
	$guard (~q_full) $call setQueuePointers (q_base_address next_wi read_index) ()


	$barrier
	$guard (lock) $call releaseMutex (q_base_address) ()
	status := (~q_full)
}

//
// to get queue length
//
$module [getQueueLength]
	$in (q_base_address : $uint<36>) $out (Queue_Length : $uint<32>)
$is
{
	$call accessMemory ($zero<1> $one<1>  (~$zero<8>)
				 (q_base_address + 8) $zero<64>) (wi_and_len)
	Queue_Length = ($slice wi_and_len 31 0)
	
}

//
// lock read  modify write (aka LDSTUB), spin till lock acquired.
//
$module [acquireMutex] $in (q_base_address: $uint<36>) $out (m_ok: $uint<1>) 
$is
{
	$branchblock[loop] {

		$volatile mutex_address_pointer := (q_base_address + ($bitcast ($uint<36>) 20) )

		$merge $entry loopback $endmerge
		
		// input arguments: lock, rwbar, bytemask, address, write-data
		// output arguments: read-data
		$call accessMemory ($one<1> $one<1> (~$zero<8>) mutex_address_pointer $zero<64>) (msg_size_plus_mutex)
		$volatile mutex_addr_32 := ($slice msg_size_plus_mutex 31 0)

		// we can either set proper bmask or split all into 8 and find the expected lock.
		$call accessMemory ($one<1> $one<1> (~$zero<8>) ($concat mutex_addr $zero<4>) $zero<64>) (mutex_values)
		
		$volatile ($split mutex_values 8 8 8 8 8 8 8 8) (m0 m1 m2 m3 m4 m5 m6 m7)

		$volatile mutex_val := //logic for selecting 8 bit lock 
		
		$if (mutex_val == (~zero<8>)) $then
			// release lock
			$call accessMemory ($zero<1> $one<1> (~$zero<8>) mutex_address_pointer $zero<64>)(err)
			$place [loopback]
		$endif
		
		$volatile new_bmask := //logic_for_bmask which will set perticular lock to 11111111
		//$volatile wval := ($concat $one<32> ($slice mutex_plus_nentries 31 0))
		$call accessMemory ($zero<1> $zero<1> new_bmask ($concat mutex_addr $zero<4>) (~$zero<64>))
						(ignore)
	}

	m_ok := $one<1>
}


//
// set mutex to 0 in queue.
//
$module [releaseMutex] $in (q_base_address: $uint<36>) $out () $is
{
		$volatile mutex_address_pointer := (q_base_address + ($bitcast ($uint<36>) 20) )
		$call accessMemory ($zero<1> $one<1> 
					(~$zero<8>) 
					 mutex_address_pointer $zero<64>) (msg_size_plus_mutex)
		
		$volatile mutex_addr_32 := ($slice msg_size_plus_mutex 31 0)
	
		$volatile new_bmask := //logic_for_bmask which will set perticular lock to 00000000

		$call accessMemory ($one<1> $zero<1> new_bmask ($concat mutex_addr $zero<4>) $zero<64>) (ignore)
}

	

//
// get wp, rp pair.
//
$module [getQueuePointers] $in (q_base_address: $uint<36>)
		$out (wp rp: $uint<32>) $is
{
		
		$call accessMemory ($zero<1> $one<1>  (~$zero<8>)
					 (q_base_address + 4) $zero<64>) (wp_rp)

		$volatile $split (wp_rp 32 32) (wp rp)
		$rreport(getQueuePointers set q_base_address wp rp)
}

//
// set wp, rp pair.
//
$module [setQueuePointers] $in (q_base_address: $uint<36> wp rp: $uint<32>) $out ()  $is
{

		$rreport(setQueuePointers set q_base_address wp rp)
		$call accessMemory ($zero<1> $zero<1>  (~$zero<8>)
					 (q_base_address + 4) ($concat wp rp)) (ignore)
}

	
//
// get element pointed to by read-index
// inside queue.
//
$module  [getQueueElement]
	$in (q_base_address: $uint<36> read_index: $uint<32>) 
	$out (q_r_data : $uint<32>)
$is
{
	$volatile buffer_address := (q_base_address + ($bitcast ($uint<36>) 24) )
	$volatile element_pair_address := (buffer_address + ($bitcast ($uint<36>) ($concat ($slice read_index 31 1) $zero<3>)))
	$call accessMemory ($zero<1> $one<1>  (~$zero<8>) element_pair_address $zero<64>) (element_pair)

	$volatile $split (element_pair 32 32) (e0 e1)
	q_r_data := ($mux (read_index [] 0) e1 e0) // Access 63 : 32 when addr[2 : 0] = 0 and

						     // Access 31:0 when addr[2 : 0] = 4

	$rreport(getQueueElement get_queue_element q_r_data q_base_address read_index element_pair_address)   
}

//
// set queue element pointed to by write
// index.
//
$module  [setQueueElement]
	$in (q_base_address: $uint<36> write_index: $uint<32> q_w_data : $uint<32>)
	$out () 
$is
{
	$volatile buffer_address := (q_base_address + ($bitcast ($uint<36>) 24) )
	$volatile element_pair_address := 
		(buffer_address + ($bitcast ($uint<36>) ($concat ($slice write_index 31 1) $zero<3>)))

	
	$volatile bmask := ($mux (write_index [] 0) 
				($concat $zero<4> (~$zero<4>))
				($concat (~ $zero<4>) $zero<4>)
				)
	$volatile wval := ($mux (write_index [] 0)
					($concat $zero<32> q_w_data)
					($concat q_w_data $zero<32>)
				)

	$rreport(setQueueElement addresses element_pair_address q_w_data bmask wval)
	$call accessMemory ($zero<1> $zero<1>  bmask
					 element_pair_address wval) (ignore)

}

